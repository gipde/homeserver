<!DOCTYPE html>
<!-- saved from url=(0085)http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Programmieren_mit_Interrupts -->
<html lang="de" class="client-js"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script async="" src="./AVR-GCC-Tutorial - Mikrocontroller.net_files/load.php"></script>
    <script type="text/javascript" async="" src="./AVR-GCC-Tutorial - Mikrocontroller.net_files/ga.js"></script><script async="" type="text/javascript" src="./AVR-GCC-Tutorial - Mikrocontroller.net_files/gpt.js"></script><script type="text/javascript">
      var wgBreakFrames = false;
      var wgContentLanguage = false;
    </script>
    
    <meta name="generator" content="MediaWiki 1.23.5">
<link rel="shortcut icon" href="http://www.mikrocontroller.net/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="http://www.mikrocontroller.net/wikisoftware/opensearch_desc.php" title="Uc-wiki (de)">
<link rel="EditURI" type="application/rsd+xml" href="http://www.mikrocontroller.net/wikisoftware/api.php?action=rsd">
<link rel="alternate" type="application/atom+xml" title="Atom-Feed für „Uc-wiki“" href="http://www.mikrocontroller.net/wikisoftware/index.php?title=Spezial:Letzte_%C3%84nderungen&feed=atom">    <title>AVR-GCC-Tutorial - Mikrocontroller.net</title>
    
        <!-- <script type="text/javascript" src="/wikisoftware/skins/common/wikibits.js"></script> -->
            <script src="./AVR-GCC-Tutorial - Mikrocontroller.net_files/load(1).php"></script><style type="text/css"></style><script src="./AVR-GCC-Tutorial - Mikrocontroller.net_files/load(2).php"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"AVR-GCC-Tutorial","wgTitle":"AVR-GCC-Tutorial","wgCurRevisionId":86634,"wgRevisionId":86634,"wgArticleId":1309,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Avr-gcc Tutorial"],"wgBreakFrames":false,"wgPageContentLanguage":"de","wgPageContentModel":"wikitext","wgSeparatorTransformTable":[",\t.",".\t,"],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","Januar","Februar","März","April","Mai","Juni","Juli","August","September","Oktober","November","Dezember"],"wgMonthNamesShort":["","Jan.","Feb.","Mär.","Apr.","Mai","Jun.","Jul.","Aug.","Sep.","Okt.","Nov.","Dez."],"wgRelevantPageName":"AVR-GCC-Tutorial","wgIsProbablyEditable":false,"wgRestrictionEdit":["autoconfirmed"],"wgRestrictionMove":["autoconfirmed"],"wgWikiEditorEnabledModules":{"toolbar":true,"dialogs":true,"hidesig":true,"preview":true,"previewDialog":false,"publish":true}});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function($,jQuery){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"editfont":"default","editondblclick":0,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":1,"extendwatchlist":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"math":0,"minordefault":0,"newpageshidepatrolled":0,"nickname":"","norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"rcdays":7,"rclimit":50,"rows":25,"showhiddencats":0,"shownumberswatching":1,"showtoolbar":1,"skin":"mikrocontroller","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":1,"watchdefault":1,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,
"useeditwarning":1,"prefershttps":1,"usebetatoolbar":1,"usebetatoolbar-cgd":1,"wikieditor-preview":1,"wikieditor-publish":1,"language":"de","variant-gan":"gan","variant-iu":"iu","variant-kk":"kk","variant-ku":"ku","variant-shi":"shi","variant-sr":"sr","variant-tg":"tg","variant-uz":"uz","variant-zh":"zh","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"variant":"de"});},{},{});mw.loader.implement("user.tokens",function($,jQuery){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});},{},{});
/* cache key: uc_wiki:resourceloader:filter:minify-js:7:e744e8cbb1c07d55ee8cfeba6da4a900 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax"]);
}</script><script src="./AVR-GCC-Tutorial - Mikrocontroller.net_files/load(3).php"></script><style type="text/css">/*<![CDATA[*/
.source-c {line-height: normal;}
.source-c li, .source-c pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for c
 * CSS class: source-c, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.c.source-c .de1, .c.source-c .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;font-family: monospace, monospace;}
.c.source-c  {font-family:monospace;}
.c.source-c .imp {font-weight: bold; color: red;}
.c.source-c li, .c.source-c .li1 {font-weight: normal; vertical-align:top;}
.c.source-c .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.c.source-c .li2 {font-weight: bold; vertical-align:top;}
.c.source-c .kw1 {color: #b1b100;}
.c.source-c .kw2 {color: #000000; font-weight: bold;}
.c.source-c .kw3 {color: #000066;}
.c.source-c .kw4 {color: #993333;}
.c.source-c .co1 {color: #666666; font-style: italic;}
.c.source-c .co2 {color: #339933;}
.c.source-c .coMULTI {color: #808080; font-style: italic;}
.c.source-c .es0 {color: #000099; font-weight: bold;}
.c.source-c .es1 {color: #000099; font-weight: bold;}
.c.source-c .es2 {color: #660099; font-weight: bold;}
.c.source-c .es3 {color: #660099; font-weight: bold;}
.c.source-c .es4 {color: #660099; font-weight: bold;}
.c.source-c .es5 {color: #006699; font-weight: bold;}
.c.source-c .br0 {color: #009900;}
.c.source-c .sy0 {color: #339933;}
.c.source-c .st0 {color: #ff0000;}
.c.source-c .nu0 {color: #0000dd;}
.c.source-c .nu6 {color: #208080;}
.c.source-c .nu8 {color: #208080;}
.c.source-c .nu12 {color: #208080;}
.c.source-c .nu16 {color:#800080;}
.c.source-c .nu17 {color:#800080;}
.c.source-c .nu18 {color:#800080;}
.c.source-c .nu19 {color:#800080;}
.c.source-c .me1 {color: #202020;}
.c.source-c .me2 {color: #202020;}
.c.source-c .ln-xtra, .c.source-c li.ln-xtra, .c.source-c div.ln-xtra {background-color: #ffc;}
.c.source-c span.xtra { display:block; }

/*]]>*/
</style>
    <script src="./AVR-GCC-Tutorial - Mikrocontroller.net_files/application-2a2200701aa6f2b224d2c48a42c5d738.js"></script>
<link rel="stylesheet" media="all" href="http://www.mikrocontroller.net/assets/screen-7503663d3813525661d54559fbe949d3.css">
<link rel="stylesheet" media="print" href="http://www.mikrocontroller.net/assets/print-c21b24fc6d13ed4b3f37f96a5f5de8ba.css">

    <!--<script src="/javascripts/highlightCurrentLink.js" type="text/javascript"></script>-->
    <link rel="shortcut icon" type="image/x-icon" href="http://www.mikrocontroller.net/favicon.ico">
    <link rel="stylesheet" type="text/css" media="screen" href="./AVR-GCC-Tutorial - Mikrocontroller.net_files/shared.css">
    <link rel="stylesheet" type="text/css" media="screen" href="./AVR-GCC-Tutorial - Mikrocontroller.net_files/main.css">
    <style type="text/css">#nav-foren-sub {display: none;} </style>
    <style type="text/css">#nav-tutorial-sub {display: none;} </style>

    <!--
    <style type="text/css">
    <div id='catlinks' class='catlinks'><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="/articles/Spezial:Kategorien" title="Spezial:Kategorien">Kategorie</a>: <ul><li><a href="/articles/Kategorie:Avr-gcc_Tutorial" title="Kategorie:Avr-gcc Tutorial">Avr-gcc Tutorial</a></li></ul></div></div>    #nav-foren-sub {display: none;}
    </style>
    -->

<link rel="stylesheet" href="http://www.mikrocontroller.net/wikisoftware/load.php?debug=false&lang=de&modules=ext.rtlcite%7Cmediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.ui.button&only=styles&skin=mikrocontroller&*">
<style>
.cite-accessibility-label{position:absolute !important; top:-99999px;clip:rect(1px 1px 1px 1px); clip:rect(1px,1px,1px,1px);padding:0 !important;border:0 !important;height:1px !important;width:1px !important;overflow:hidden}.mw-cite-backlink,.cite-accessibility-label{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}
/* cache key: uc_wiki:resourceloader:filter:minify-css:7:a59b70abe6ecaa39388bb79ebc509cb0 */
.mw-collapsible-toggle{float:right;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none} caption .mw-collapsible-toggle{float:none} li .mw-collapsible-toggle{float:none} .mw-collapsible-toggle-li{list-style:none}
/* cache key: uc_wiki:resourceloader:filter:minify-css:7:6c1d24e90626cec584f0869483f983e7 */
.suggestions{overflow:hidden;position:absolute;top:0;left:0;width:0;border:none;z-index:1099;padding:0;margin:-1px -1px 0 0} html > body .suggestions{margin:-1px 0 0 0}.suggestions-special{position:relative;background-color:white;cursor:pointer;border:solid 1px #aaaaaa;padding:0;margin:0;margin-top:-2px;display:none;padding:0.25em 0.25em;line-height:1.25em}.suggestions-results{background-color:white;cursor:pointer;border:solid 1px #aaaaaa;padding:0;margin:0}.suggestions-result{color:black;margin:0;line-height:1.5em;padding:0.01em 0.25em;text-align:left; overflow:hidden;-o-text-overflow:ellipsis; text-overflow:ellipsis;white-space:nowrap}.suggestions-result-current{background-color:#4C59A6;color:white}.suggestions-special .special-label{color:gray;text-align:left}.suggestions-special .special-query{color:black;font-style:italic;text-align:left}.suggestions-special .special-hover{background-color:silver}.suggestions-result-current .special-label,.suggestions-result-current .special-query{color:white}.highlight{font-weight:bold}
/* cache key: uc_wiki:resourceloader:filter:minify-css:7:9f9511aa4ef920d34591113e825e6a1e */
.postedit-container{margin:0 auto;position:fixed;top:0;height:0;left:50%;z-index:1000;font-size:13px}.postedit-container:hover{cursor:pointer}.postedit{position:relative;top:0.6em;left:-50%;padding:.6em 3.6em .6em 1.1em;line-height:1.5625em;color:#626465;background-color:#f4f4f4;border:1px solid #dcd9d9;text-shadow:0 0.0625em 0 rgba(255,255,255,0.5);border-radius:5px;-webkit-box-shadow:0 2px 5px 0 #ccc;box-shadow:0 2px 5px 0 #ccc;-webkit-transition:all 0.25s ease-in-out;-moz-transition:all 0.25s ease-in-out;-ms-transition:all 0.25s ease-in-out;-o-transition:all 0.25s ease-in-out;transition:all 0.25s ease-in-out}.skin-monobook .postedit{top:6em !important}.postedit-faded{opacity:0}.postedit-icon{padding-left:41px;  line-height:25px;background-repeat:no-repeat;background-position:8px 50%}.postedit-icon-checkmark{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABblBMVEUAAAD///////9PfTf///80aRdTgjn///9Feij///////////9Rfzf///////////9PfjZRgDh1o1xOfTb///////+bwYqLtnj///////9PfTa82K////9WhT6YxIL///9QgDdTgzr////////j7uDl7eLq8efi693k7OH///////9UhjuBr2rp9uRUhjr///9YljVKgir///9WiTlYjT3////9/v57vFlbkT5PjC9dlD/5/fhuq09stUTs9uhxuElctCpfnT1huDFloEZloUZmpENmvDZpvDxpvTxqvjxrvT5rvT9rwTxsqktswD5uwkBvuUdxw0NztFBztU9ztVBzwkp0tlJ1xkd2t1R3uVR4w1F4xk54x014yE15uVZ5v1R5xVB6v1R7yFJ8wVh9xVl9yFR9yVd9ylN+xVh+yFd/x1l/yFeAylmEx1+Ny2uY0Hqe04Wj1Ymv3Ze33qLD47TJ5L3O6cPU7Mrq9eb2+/Q4j37OAAAAQHRSTlMAAQIEBAUFBQwPFB4fJCUoKiosQEhJS01RUlZZXmdydXaChYuSlJSWmJmoq6uur8LExcvM19fg5ejt8fX2+Pr7SljgewAAAKpJREFUGBkFwQNCAwAAAMDLtl3LtrG4rWXbtvX77gAgZ6grFwC0bhwNVgKgdPZx8b0dgLi+s7Wn0VoAqpfOI9+BNADZI7fLrz2pSEwGHZuH+78lSK8ZLkLezF3ooyUG3VPXq2USei9WngeyoG195yBYWDF3E/2pAhl1e9Gr8bGT+bfOFCC2fnvh4X7rcqIAQNNu+HT6sxkAjceTL/2ZAIhv+PorBwBJxfkA//dFHSCBy/UTAAAAAElFTkSuQmCC);background-image:url(http://www.mikrocontroller.net/wikisoftware/resources/src/mediawiki.action/images/green-checkmark.png?2015-03-11T07:58:20Z)!ie;background-position:left}.postedit-close{position:absolute;padding:0 .8em;right:0;top:0;font-size:1.25em;font-weight:bold;line-height:2.3em;color:black;text-shadow:0 0.0625em 0 white;text-decoration:none;opacity:0.2;filter:alpha(opacity=20)}.postedit-close:hover{color:black;text-decoration:none;opacity:0.4;filter:alpha(opacity=40)}
/* cache key: uc_wiki:resourceloader:filter:minify-css:7:6a5592fac97179252130711d4bd2381f */</style><style>
.suggestions a.mw-searchSuggest-link,.suggestions a.mw-searchSuggest-link:hover,.suggestions a.mw-searchSuggest-link:active,.suggestions a.mw-searchSuggest-link:focus{color:black;text-decoration:none}.suggestions-result-current a.mw-searchSuggest-link,.suggestions-result-current a.mw-searchSuggest-link:hover,.suggestions-result-current a.mw-searchSuggest-link:active,.suggestions-result-current a.mw-searchSuggest-link:focus{color:white}.suggestions a.mw-searchSuggest-link .special-query{ overflow:hidden;-o-text-overflow:ellipsis; text-overflow:ellipsis;white-space:nowrap}
/* cache key: uc_wiki:resourceloader:filter:minify-css:7:ae3fa4570b5ac0c6cf7b3776c8ae4d6f */</style><meta name="ResourceLoaderDynamicStyles" content="">
<link rel="stylesheet" href="http://www.mikrocontroller.net/wikisoftware/load.php?debug=false&lang=de&modules=site&only=styles&skin=mikrocontroller&*">
<style>a:lang(ar),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: uc_wiki:resourceloader:filter:minify-css:7:54d5fe6622ad6975d261994c27a3259c */</style>

<script type="text/javascript">
var googletag = googletag || {};
googletag.cmd = googletag.cmd || [];
(function() {
var gads = document.createElement('script');
gads.async = true;
gads.type = 'text/javascript';
var useSSL = 'https:' == document.location.protocol;
gads.src = (useSSL ? 'https:' : 'http:') + 
'//www.googletagservices.com/tag/js/gpt.js';
var node = document.getElementsByTagName('script')[0];
node.parentNode.insertBefore(gads, node);
})();

googletag.cmd.push(function() {
  //googletag.pubads().enableSingleRequest();
  googletag.pubads().setTargeting('pagetype', 'article');
  googletag.pubads().setTargeting('section', 'article');
  if ('https:' == document.location.protocol) {
    googletag.pubads().setTargeting('ssl', '1');
  } else {
    googletag.pubads().setTargeting('ssl', '0');
  }
      googletag.pubads().setTargeting('site_id', '1');
  });
</script>


<script type="text/javascript">
  var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-80574-1']);
  
  if (typeof googletag.pubads == 'function') {
    _gaq.push(['_setCustomVar', 3, "GAM", "Yes", 1]);
  } else {
    _gaq.push(['_setCustomVar', 3, "GAM", "No", 1]);
  }
  _gaq.push(['_trackPageview']);
  _gaq.push(['_trackPageLoadTime']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>

<body>
	<div id="outer-container">
    <div id="globalWrapper">
    <div id="top"><h1><a href="http://www.mikrocontroller.net/">www.mikrocontroller.net</a></h1></div>
  <table id="twocolumns">
  <tbody><tr>
  <td id="sidebar-left" class="sidebar">
  <!-- begin nav -->
<div class="nav-container">
  <ul class="nav-first">
    <li><b><a href="http://www.mikrocontroller.net/">Home</a></b></li>
    <li>
      <b><a href="http://www.mikrocontroller.net/articles/AVR">AVR</a></b>
      <ul>
        <li><a href="http://www.mikrocontroller.net/articles/AVR-Tutorial">AVR-Tutorial</a></li>
        <li><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial" class="currentlink">AVR-GCC-Tutorial</a></li>
      </ul>
    </li>
    <li>
      <b><a href="http://www.mikrocontroller.net/articles/ARM">ARM</a></b>
      <ul>
        <li><a href="http://www.mikrocontroller.net/articles/LPC1xxx">LPC1xxx</a></li>
        <li><a href="http://www.mikrocontroller.net/articles/STM32">STM32</a></li>
        <li><a href="http://www.mikrocontroller.net/articles/Infineon_XMC">XMC</a></li>
      </ul>
    </li>
    <li>
      <b><a href="http://www.mikrocontroller.net/articles/MSP430">MSP430</a></b>
    </li>
    <li>
      <b><a href="http://www.mikrocontroller.net/articles/Programmierbare_Logik">FPGA, CPLD &amp; Co.</a></b>
      <ul>
        <li><a href="http://www.mikrocontroller.net/articles/FPGA">Grundlagen zu FPGAs</a></li>
        <li><a href="http://www.mikrocontroller.net/articles/Hardwarebeschreibungssprachen">VHDL &amp; Co.</a></li>
        <li><a href="http://www.mikrocontroller.net/articles/Xilinx_ISE">Xilinx ISE</a></li>
      </ul>
    </li>
    <li>
      <b><a href="http://www.mikrocontroller.net/articles/Digitale_Signalverarbeitung">DSP</a></b>
    </li>

    <li>
      <b><a href="http://www.mikrocontroller.net/articles/Elektronik_Allgemein">Elektronik allgemein</a></b>
      <ul>
        <li><a href="http://www.mikrocontroller.net/articles/SMD_L%C3%B6ten">SMD Löten</a></li>
        <li><a href="http://www.mikrocontroller.net/articles/Operationsverst%C3%A4rker-Grundschaltungen">Operationsverstärker</a></li>
        <li><a href="http://www.mikrocontroller.net/articles/Oszilloskop">Oszilloskop</a></li>
      </ul> 
    </li>

    <li>
      <b><a href="http://www.mikrocontroller.net/forum/all">Forum</a></b>
      <ul>
        <li><a href="http://www.mikrocontroller.net/forum/mikrocontroller-elektronik">µC &amp; Elektronik</a></li>
        <li><a href="http://www.mikrocontroller.net/forum/analogtechnik">Analogtechnik</a></li>
        <li><a href="http://www.mikrocontroller.net/forum/fpga-vhdl-cpld">FPGA, VHDL &amp; Co.</a></li>
        <li><a href="http://www.mikrocontroller.net/forum/dsp">DSP</a></li>
        <li><a href="http://www.mikrocontroller.net/forum/gcc">GCC</a></li>
        <li><a href="http://www.mikrocontroller.net/forum/codesammlung">Projekte &amp; Code</a></li>
        <li><a href="http://www.mikrocontroller.net/forum/markt">Markt</a></li>
        <li><a href="http://www.mikrocontroller.net/forum/platinen">Platinen</a></li>
        <li><a href="http://www.mikrocontroller.net/forum/mechanik">Mechanik &amp; Werkzeug</a></li>
        <li><a href="http://www.mikrocontroller.net/forum/hf">HF, Funk &amp; Felder</a></li>
        <li><a href="http://www.mikrocontroller.net/forum/hausbus">Haus &amp; Smart Home</a></li>
        <li><a href="http://www.mikrocontroller.net/forum/pc-programmierung">PC-Programmierung</a></li>
        <li><a href="http://www.mikrocontroller.net/forum/pc-hardware-software">PC Hard- &amp; Software</a></li>
        <li><a href="http://www.mikrocontroller.net/forum/ausbildung-studium-beruf">Ausbildung &amp; Beruf</a></li>
        <li><a href="http://www.mikrocontroller.net/forum/offtopic">Offtopic</a></li>
        <li><a href="http://www.mikrocontroller.net/forum/website">Webseite</a></li>
       </ul>
    </li>
<!--    <li><b><a href="/buecher/">Buchtipps</a></b></li>-->
<!--    <li><b><a href="http://shop.mikrocontroller.net/">Shop</a></b></li>-->
<!--    <li><b><a href="/articles/Linksammlung">Linksammlung</a></b></li>-->
    <li><b><a href="http://www.mikrocontroller.net/articles/Hauptseite">Artikelübersicht</a></b></li>
    <li><b><a href="http://www.mikrocontroller.net/articles/Spezial:Recentchanges">Letzte Änderungen</a></b></li>
  </ul>
</div>
<!-- end nav -->
  <hr>
  <!-- google_ad_section_start(weight=ignore) -->

<script type="text/javascript">
<!--
    function toggle_visibility(id) {
       var e = document.getElementById(id);
       if(e.style.display == 'block')
          e.style.display = 'none';
       else
          e.style.display = 'block';
    }
//-->
</script>

	<div id="p-cactions" class="portlet">
	  <h5><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#toggle" onclick="javascript:toggle_visibility(&#39;p-cactions-box&#39;); return false;">▶ Dieser Artikel</a></h5>
	  <div class="box" id="p-cactions-box">
      <ul>
	    <li id="ca-nstab-main" class="selected"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial" class="currentlink">Seite</a></li><li id="ca-talk"><a href="http://www.mikrocontroller.net/articles/Diskussion:AVR-GCC-Tutorial">Diskussion</a></li><li id="ca-viewsource"><a href="http://www.mikrocontroller.net/wikisoftware/index.php?title=AVR-GCC-Tutorial&action=edit">Quelltext anzeigen</a></li><li id="ca-history"><a href="http://www.mikrocontroller.net/wikisoftware/index.php?title=AVR-GCC-Tutorial&action=history">Versionsgeschichte</a></li>  	  </ul>
    </div>
	</div>
	<div class="portlet" id="p-personal">
	  <h5><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#toggle" onclick="javascript:toggle_visibility(&#39;p-personal-box&#39;); return false;">▶ Benutzer</a></h5>
	  <div class="box" id="p-personal-box">
	    <ul>
	    <li id="pt-login"><a href="http://www.mikrocontroller.net/wikisoftware/index.php?title=Spezial:Anmelden&returnto=AVR-GCC-Tutorial">Anmelden</a></li>	    </ul>
	  </div>
	</div>
  <!-- LOGO
	<div class="portlet" id="p-logo">
	  <a style="background-image: url(/wikisoftware/skins/common/images/wiki.png);"
	    href="/articles/Hauptseite"
	    title="Hauptseite"></a>
	</div>
  -->
	<div id="p-search" class="portlet">
	  <h5><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#toggle" onclick="javascript:toggle_visibility(&#39;p-search-box&#39;); return false;">▶ Suche</a></h5>
	  <div class="box" id="p-search-box">
	    <form name="searchform" action="http://www.mikrocontroller.net/articles/Spezial:Suche" id="searchform">
	      <input id="searchInputX" name="search" type="text" accesskey="f" value=""><br>
	      <input type="submit" name="go" class="searchButton" value="Ausführen">&nbsp;<input type="submit" name="fulltext" class="searchButton" value="Suche">
	    </form>
	  </div>
	</div>
	<div class="portlet" id="p-tb">
	  <h5><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#toggle" onclick="javascript:toggle_visibility(&#39;p-tb-box&#39;); return false;">▶ Werkzeuge</a></h5>
	    <div class="box" id="p-tb-box">
      <ul>
		  		  <li id="t-whatlinkshere"><a href="http://www.mikrocontroller.net/articles/Spezial:Linkliste/AVR-GCC-Tutorial">Links auf diese Seite</a></li>
		  		  <li id="t-recentchangeslinked"><a href="http://www.mikrocontroller.net/articles/Spezial:%C3%84nderungen_an_verlinkten_Seiten/AVR-GCC-Tutorial">Änderungen an verlinkten Seiten</a></li>
		  	      	      	      	      	      	      	      	      	      <li id="t-specialpages"><a href="http://www.mikrocontroller.net/articles/Spezial:Spezialseiten">Spezialseiten</a></li>	      	    </ul>
      </div>
	</div>
  <!-- google_ad_section_end -->
  
  <!-- start adsense -->
    <!-- end adsense -->
  
      </td><!-- end of the left (by default at least) column -->
  <td id="main">
    <!-- google_ad_section_start -->
    <a name="top" id="contentTop"></a>
    		<div id="content">
    <h1 class="firstHeading">AVR-GCC-Tutorial</h1>
    <div id="bodyContent">

						<!-- tagline -->
			<!-- <div id="siteSub">Aus Uc-wiki</div> -->
			<!-- /tagline -->
						<!-- subtitle -->
			<div id="contentSub"></div>
			<!-- /subtitle -->
												<!-- jumpto -->
			<div id="jump-to-nav" class="mw-jump">
				Wechseln zu:				<a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#mw-navigation">Navigation</a>, 				<a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#p-search">Suche</a>
			</div>
			<!-- /jumpto -->
						<!-- bodycontent -->
			<div id="mw-content-text" lang="de" dir="ltr" class="mw-content-ltr"><p>Dieses Tutorial soll den Einstieg in die Programmierung von Atmel <a href="http://www.mikrocontroller.net/articles/AVR" title="AVR">AVR</a>-Mikrocontrollern in der Programmiersprache <a href="http://www.mikrocontroller.net/articles/C" title="C">C</a> mit dem freien C-Compiler <a href="http://www.mikrocontroller.net/articles/Avr-gcc" title="Avr-gcc" class="mw-redirect">avr-gcc</a> aus der <a rel="nofollow" class="external text" href="http://gcc.gnu.org/">GNU Compiler Collection</a> (GCC) erleichtern.
</p><p>Vorausgesetzt werden Grundkenntnisse der Programmiersprache C. Diese Kenntnisse kann man sich online erarbeiten, z. B. mit dem <a rel="nofollow" class="external text" href="http://www.schellong.de/c.htm">C Tutorial von Helmut Schellong</a> (<a href="http://www.mikrocontroller.net/articles/C" title="C">Liste von C-Tutorials</a>). Nicht erforderlich sind Vorkenntnisse in der Programmierung von Mikrocontrollern.
</p>
<div id="toc" class="toc"><div id="toctitle"><h2>Inhaltsverzeichnis</h2><span class="toctoggle">&nbsp;[<a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#" class="internal" id="togglelink">Verbergen</a>]&nbsp;</span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Vorwort"><span class="tocnumber">1</span> <span class="toctext">Vorwort</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Weiterf.C3.BChrende_Kapitel"><span class="tocnumber">1.1</span> <span class="toctext">Weiterführende Kapitel</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-3"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Ben.C3.B6tigte_Werkzeuge"><span class="tocnumber">2</span> <span class="toctext">Benötigte Werkzeuge</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Was_tun.2C_wenn.27s_nicht_klappt.3F"><span class="tocnumber">3</span> <span class="toctext">Was tun, wenn's nicht klappt?</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Erzeugen_von_Maschinencode"><span class="tocnumber">4</span> <span class="toctext">Erzeugen von Maschinencode</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Einf.C3.BChrungsbeispiel"><span class="tocnumber">5</span> <span class="toctext">Einführungsbeispiel</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Ganzzahlige_Datentypen_.28Integer.29"><span class="tocnumber">6</span> <span class="toctext">Ganzzahlige Datentypen (Integer)</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Grunds.C3.A4tzlicher_Programmaufbau_eines_.C2.B5C-Programms"><span class="tocnumber">7</span> <span class="toctext">Grundsätzlicher Programmaufbau eines µC-Programms</span></a>
<ul>
<li class="toclevel-2 tocsection-9"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Sequentieller_Programmablauf"><span class="tocnumber">7.1</span> <span class="toctext">Sequentieller Programmablauf</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Interruptgesteuerter_Programmablauf"><span class="tocnumber">7.2</span> <span class="toctext">Interruptgesteuerter Programmablauf</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-11"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Zugriff_auf_Register"><span class="tocnumber">8</span> <span class="toctext">Zugriff auf Register</span></a>
<ul>
<li class="toclevel-2 tocsection-12"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Schreiben_in_Register"><span class="tocnumber">8.1</span> <span class="toctext">Schreiben in Register</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Ver.C3.A4ndern_von_Registerinhalten"><span class="tocnumber">8.2</span> <span class="toctext">Verändern von Registerinhalten</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Lesen_aus_Registern"><span class="tocnumber">8.3</span> <span class="toctext">Lesen aus Registern</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Warten_auf_einen_bestimmten_Zustand"><span class="tocnumber">8.4</span> <span class="toctext">Warten auf einen bestimmten Zustand</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#16-Bit_Register_.28ADC.2C_ICR1.2C_OCR1x.2C_TCNT1.2C_UBRR.29"><span class="tocnumber">8.5</span> <span class="toctext">16-Bit Register (ADC, ICR1, OCR1x, TCNT1, UBRR)</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#IO-Register_als_Parameter_und_Variablen"><span class="tocnumber">8.6</span> <span class="toctext">IO-Register als Parameter und Variablen</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-18"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Zugriff_auf_IO-Ports"><span class="tocnumber">9</span> <span class="toctext">Zugriff auf IO-Ports</span></a>
<ul>
<li class="toclevel-2 tocsection-19"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Datenrichtung_bestimmen"><span class="tocnumber">9.1</span> <span class="toctext">Datenrichtung bestimmen</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Vordefinierte_Bitnummern_f.C3.BCr_I.2FO-Register"><span class="tocnumber">9.2</span> <span class="toctext">Vordefinierte Bitnummern für I/O-Register</span></a></li>
<li class="toclevel-2 tocsection-21"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Digitale_Signale"><span class="tocnumber">9.3</span> <span class="toctext">Digitale Signale</span></a></li>
<li class="toclevel-2 tocsection-22"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Ausg.C3.A4nge"><span class="tocnumber">9.4</span> <span class="toctext">Ausgänge</span></a></li>
<li class="toclevel-2 tocsection-23"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Eing.C3.A4nge_.28Wie_kommen_Signale_in_den_.C2.B5C.29"><span class="tocnumber">9.5</span> <span class="toctext">Eingänge (Wie kommen Signale in den µC)</span></a>
<ul>
<li class="toclevel-3 tocsection-24"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Signalkopplung"><span class="tocnumber">9.5.1</span> <span class="toctext">Signalkopplung</span></a></li>
<li class="toclevel-3 tocsection-25"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Interne_Pull-Up_Widerst.C3.A4nde"><span class="tocnumber">9.5.2</span> <span class="toctext">Interne Pull-Up Widerstände</span></a></li>
<li class="toclevel-3 tocsection-26"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Taster_und_Schalter"><span class="tocnumber">9.5.3</span> <span class="toctext">Taster und Schalter</span></a>
<ul>
<li class="toclevel-4 tocsection-27"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Taster_entprellen"><span class="tocnumber">9.5.3.1</span> <span class="toctext">Taster entprellen</span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-28"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Warteschleifen_.28delay.h.29"><span class="tocnumber">10</span> <span class="toctext">Warteschleifen (delay.h)</span></a>
<ul>
<li class="toclevel-2 tocsection-29"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#avr-libc_Versionen_bis_1.6"><span class="tocnumber">10.1</span> <span class="toctext">avr-libc Versionen bis 1.6</span></a></li>
<li class="toclevel-2 tocsection-30"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#avr-libc_Versionen_ab_1.7"><span class="tocnumber">10.2</span> <span class="toctext">avr-libc Versionen ab 1.7</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-31"><a href="./AVR-GCC-Tutorial - Mikrocontroller.net_files/AVR-GCC-Tutorial - Mikrocontroller.net.html"><span class="tocnumber">11</span> <span class="toctext">Programmieren mit Interrupts</span></a>
<ul>
<li class="toclevel-2 tocsection-32"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Anforderungen_an_Interrupt-Routinen"><span class="tocnumber">11.1</span> <span class="toctext">Anforderungen an Interrupt-Routinen</span></a></li>
<li class="toclevel-2 tocsection-33"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Interrupt-Quellen"><span class="tocnumber">11.2</span> <span class="toctext">Interrupt-Quellen</span></a></li>
<li class="toclevel-2 tocsection-34"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Register"><span class="tocnumber">11.3</span> <span class="toctext">Register</span></a></li>
<li class="toclevel-2 tocsection-35"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Allgemeines_.C3.BCber_die_Interrupt-Abarbeitung"><span class="tocnumber">11.4</span> <span class="toctext">Allgemeines über die Interrupt-Abarbeitung</span></a></li>
<li class="toclevel-2 tocsection-36"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Interrupts_mit_avr-gcc"><span class="tocnumber">11.5</span> <span class="toctext">Interrupts mit avr-gcc</span></a>
<ul>
<li class="toclevel-3 tocsection-37"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#ISR"><span class="tocnumber">11.5.1</span> <span class="toctext">ISR</span></a></li>
<li class="toclevel-3 tocsection-38"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Unterbrechbare_Interruptroutinen"><span class="tocnumber">11.5.2</span> <span class="toctext">Unterbrechbare Interruptroutinen</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-39"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Datenaustausch_mit_Interrupt-Routinen"><span class="tocnumber">11.6</span> <span class="toctext">Datenaustausch mit Interrupt-Routinen</span></a>
<ul>
<li class="toclevel-3 tocsection-40"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#volatile_und_Pointer"><span class="tocnumber">11.6.1</span> <span class="toctext">volatile und Pointer</span></a></li>
<li class="toclevel-3 tocsection-41"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Variablen_gr.C3.B6.C3.9Fer_1_Byte"><span class="tocnumber">11.6.2</span> <span class="toctext">Variablen größer 1 Byte</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-42"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Interrupt-Routinen_und_Registerzugriffe"><span class="tocnumber">11.7</span> <span class="toctext">Interrupt-Routinen und Registerzugriffe</span></a></li>
<li class="toclevel-2 tocsection-43"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Interruptflags_l.C3.B6schen"><span class="tocnumber">11.8</span> <span class="toctext">Interruptflags löschen</span></a></li>
<li class="toclevel-2 tocsection-44"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Was_macht_das_Hauptprogramm.3F"><span class="tocnumber">11.9</span> <span class="toctext">Was macht das Hauptprogramm?</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-45"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Sleep-Modes"><span class="tocnumber">12</span> <span class="toctext">Sleep-Modes</span></a>
<ul>
<li class="toclevel-2 tocsection-46"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Sleep_Modi"><span class="tocnumber">12.1</span> <span class="toctext">Sleep Modi</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-47"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Zeiger"><span class="tocnumber">13</span> <span class="toctext">Zeiger</span></a></li>
<li class="toclevel-1 tocsection-48"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Speicherzugriffe"><span class="tocnumber">14</span> <span class="toctext">Speicherzugriffe</span></a>
<ul>
<li class="toclevel-2 tocsection-49"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#RAM"><span class="tocnumber">14.1</span> <span class="toctext">RAM</span></a></li>
<li class="toclevel-2 tocsection-50"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Flash_mit_PROGMEM_und_pgm_read"><span class="tocnumber">14.2</span> <span class="toctext">Flash mit PROGMEM und pgm_read</span></a>
<ul>
<li class="toclevel-3 tocsection-51"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Integer_und_float"><span class="tocnumber">14.2.1</span> <span class="toctext">Integer und float</span></a></li>
<li class="toclevel-3 tocsection-52"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Bl.C3.B6cke"><span class="tocnumber">14.2.2</span> <span class="toctext">Blöcke</span></a></li>
<li class="toclevel-3 tocsection-53"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Strings"><span class="tocnumber">14.2.3</span> <span class="toctext">Strings</span></a></li>
<li class="toclevel-3 tocsection-54"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Warum_so_kompliziert.3F"><span class="tocnumber">14.2.4</span> <span class="toctext">Warum so kompliziert?</span></a></li>
<li class="toclevel-3 tocsection-55"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Variablenzugriff_.3E64kB"><span class="tocnumber">14.2.5</span> <span class="toctext">Variablenzugriff &gt;64kB</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-56"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Flash_mit_flash_und_Embedded-C"><span class="tocnumber">14.3</span> <span class="toctext">Flash mit __flash und Embedded-C</span></a>
<ul>
<li class="toclevel-3 tocsection-57"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Bl.C3.B6cke_2"><span class="tocnumber">14.3.1</span> <span class="toctext">Blöcke</span></a></li>
<li class="toclevel-3 tocsection-58"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Strings_2"><span class="tocnumber">14.3.2</span> <span class="toctext">Strings</span></a></li>
<li class="toclevel-3 tocsection-59"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Casts"><span class="tocnumber">14.3.3</span> <span class="toctext">Casts</span></a></li>
<li class="toclevel-3 tocsection-60"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Jenseits_von_flash"><span class="tocnumber">14.3.4</span> <span class="toctext">Jenseits von __flash</span></a></li>
<li class="toclevel-3 tocsection-61"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#flash.2C_progmem_und_Portierbarkeit"><span class="tocnumber">14.3.5</span> <span class="toctext">__flash, progmem und Portierbarkeit</span></a>
<ul>
<li class="toclevel-4 tocsection-62"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#progmem_.E2.86.92_flash"><span class="tocnumber">14.3.5.1</span> <span class="toctext">progmem → __flash</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-2 tocsection-63"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Flash_in_der_Anwendung_schreiben"><span class="tocnumber">14.4</span> <span class="toctext">Flash in der Anwendung schreiben</span></a></li>
<li class="toclevel-2 tocsection-64"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#EEPROM"><span class="tocnumber">14.5</span> <span class="toctext">EEPROM</span></a>
<ul>
<li class="toclevel-3 tocsection-65"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#EEMEM"><span class="tocnumber">14.5.1</span> <span class="toctext">EEMEM</span></a></li>
<li class="toclevel-3 tocsection-66"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Bytes_lesen.2Fschreiben"><span class="tocnumber">14.5.2</span> <span class="toctext">Bytes lesen/schreiben</span></a></li>
<li class="toclevel-3 tocsection-67"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Wort_lesen.2Fschreiben"><span class="tocnumber">14.5.3</span> <span class="toctext">Wort lesen/schreiben</span></a></li>
<li class="toclevel-3 tocsection-68"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Block_lesen.2Fschreiben"><span class="tocnumber">14.5.4</span> <span class="toctext">Block lesen/schreiben</span></a></li>
<li class="toclevel-3 tocsection-69"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Flie.C3.9Fkommawerte_lesen.2Fschreiben"><span class="tocnumber">14.5.5</span> <span class="toctext">Fließkommawerte lesen/schreiben</span></a></li>
<li class="toclevel-3 tocsection-70"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#EEPROM-Speicherabbild_in_.eep-Datei"><span class="tocnumber">14.5.6</span> <span class="toctext">EEPROM-Speicherabbild in .eep-Datei</span></a></li>
<li class="toclevel-3 tocsection-71"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Direkter_Zugriff_auf_EEPROM-Adressen"><span class="tocnumber">14.5.7</span> <span class="toctext">Direkter Zugriff auf EEPROM-Adressen</span></a></li>
<li class="toclevel-3 tocsection-72"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#EEPROM_Register"><span class="tocnumber">14.5.8</span> <span class="toctext">EEPROM Register</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-73"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Die_Nutzung_von_sprintf_und_printf"><span class="tocnumber">15</span> <span class="toctext">Die Nutzung von sprintf und printf</span></a></li>
<li class="toclevel-1 tocsection-74"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Anmerkungen"><span class="tocnumber">16</span> <span class="toctext">Anmerkungen</span></a></li>
<li class="toclevel-1 tocsection-75"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#TODO"><span class="tocnumber">17</span> <span class="toctext">TODO</span></a></li>
</ul>
</div>

<h1><span class="mw-headline" id="Vorwort">Vorwort</span></h1>
<p>In diesem Text wird häufig auf die Standardbibliothek avr-libc verwiesen, für die es eine <a rel="nofollow" class="external text" href="http://www.nongnu.org/avr-libc/user-manual/index.html">Online-Dokumentation</a> gibt, in der sich auch viele nützliche Informationen zum Compiler und zur Programmierung von AVR-Controllern finden. Beim Paket <a href="http://www.mikrocontroller.net/articles/WinAVR" title="WinAVR">WinAVR</a> gehört die avr-libc Dokumentation zum Lieferumfang und wird mitinstalliert.
</p><p>Der Compiler und die Standardbibliothek avr-libc werden ständig weiterentwickelt. Einige Unterschiede, die sich im Verlauf der Entwicklung ergeben haben, werden hier und im Artikel <a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial/Alte_Quellen" title="AVR-GCC-Tutorial/Alte Quellen">Alte Quellen</a> zwar angesprochen, Anfängern und Umsteigern sei jedoch empfohlen, eine aktuelle Versionen zu nutzen.
</p><p>Das ursprüngliche Tutorial stammt von Christian Schifferle, viele neue Abschnitte und aktuelle Anpassungen von Martin Thomas.
</p><p>Dieses Tutorial ist in <a href="http://www.mikrocontroller.net/wikifiles/1/1b/AVR-GCC-Tutorial.pdf" class="internal" title="AVR-GCC-Tutorial.pdf">PDF-Form</a> erhältlich (nicht immer auf aktuellem Stand).
</p>
<h2><span class="mw-headline" id="Weiterf.C3.BChrende_Kapitel">Weiterführende Kapitel</span></h2>
<p>Um dieses riesige Tutorial etwas überschaubarer zu gestalten, wurden einige Kapitel ausgelagert, die nicht unmittelbar mit den Grundlagen von avr-gcc in Verbindung stehen. All diese Seiten gehören zur <a href="http://www.mikrocontroller.net/articles/Kategorie:Avr-gcc_Tutorial" title="Kategorie:Avr-gcc Tutorial">Kategorie:avr-gcc Tutorial</a>.
</p>
<dl>
<dt>UART</dt>
<dd> → Hauptartikel: <i><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial/Der_UART" title="AVR-GCC-Tutorial/Der UART">Der UART</a></i>
</dd>
</dl>
<dl>
<dt>ADC</dt>
<dd> → Hauptartikel: <i><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial/Analoge_Ein-_und_Ausgabe" title="AVR-GCC-Tutorial/Analoge Ein- und Ausgabe">Analoge Ein- und Ausgabe (ADC)</a></i>
</dd>
</dl>
<dl>
<dt>Timer</dt>
<dd> → Hauptartikel: <i><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial/Die_Timer_und_Z%C3%A4hler_des_AVR" title="AVR-GCC-Tutorial/Die Timer und Zähler des AVR">Die Timer und Zähler des AVR</a></i>
</dd>
</dl>
<dl>
<dt>LCD</dt>
<dd> → Hauptartikel: <i><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial/LCD-Ansteuerung" title="AVR-GCC-Tutorial/LCD-Ansteuerung">LCD-Ansteuerung</a></i>
</dd>
</dl>
<dl>
<dt>Watchdog</dt>
<dd> → Hauptartikel: <i><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial/Der_Watchdog" title="AVR-GCC-Tutorial/Der Watchdog">Der Watchdog</a></i>
</dd>
</dl>
<dl>
<dt>Assembler</dt>
<dd> → Hauptartikel: <i><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial/Assembler_und_Inline-Assembler" title="AVR-GCC-Tutorial/Assembler und Inline-Assembler">Assembler und Inline-Assembler</a></i>
</dd>
</dl>
<dl>
<dt>alte Quellen anpassen</dt>
<dd> → Hauptartikel: <i><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial/Alte_Quellen" title="AVR-GCC-Tutorial/Alte Quellen">Alte Quellen anpassen</a></i>
</dd>
</dl>
<dl>
<dt>Makefiles</dt>
<dd> → Hauptartikel: <i><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial/Exkurs_Makefiles" title="AVR-GCC-Tutorial/Exkurs Makefiles">Exkurs Makefiles</a></i> sowie als Alternative für sehr kleine Projekte → Hauptartikel: <i><a href="http://www.mikrocontroller.net/articles/C_ohne_Makefile" title="C ohne Makefile">C ohne Makefile</a></i>
</dd>
</dl>
<h1><span class="mw-headline" id="Ben.C3.B6tigte_Werkzeuge">Benötigte Werkzeuge</span></h1>
<p>Um eigene Programme für AVRs mittels einer AVR-Toolchain zu erstellen wird folgende Hard- und Software benötigt:
</p>
<ul>
<li> Eine AVR-Toolchain bestehend aus avr-gcc, den avr-Binutils (Assembler, Linker, etc) und einer Standard-C Bibliothek.  Üblich ist die AVR-LibC, die auch quasi in allen avr-gcc Distributionen enthalten ist.
</li>
</ul>
<p>Hardware wird keine benötigt – bis auf einen PC natürlich, auf dem der Compiler ablaufen kann.  Selbst ohne AVR-Hardware kann man also bereits C-Programme für AVRs schreiben, compiliern und sich das Look-and-Feel von avr-gcc sowie von IDEs wie <a href="http://www.mikrocontroller.net/articles/Atmel_Studio" title="Atmel Studio">Atmel Studio</a>, Eclipse oder leichtgewichtigeren Entwicklungsumbgebungen anschauen. Selbst das Debuggen und Simulieren ist mithilfe entsprechender Tools wie Debugger und Simulator in gewissen Grenzen möglich.
</p><p>Um Programme für AVRs mittels einer AVR-Toolchain zu testen, wird folgende Hard- und Software benötigt:
</p>
<ul>
<li> Platine oder Versuchsaufbau für die Aufnahme eines AVR-Controllers, der vom avr-gcc Compiler unterstützt wird.<sup id="cite_ref-1" class="reference"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#cite_note-1">[1]</a></sup> Dieses Testboard kann durchaus auch selbst gelötet oder auf einem Steckbrett aufgebaut werden. Einige Registerbeschreibungen dieses Tutorials beziehen sich auf den inzwischen veralteten AT90S2313. Der weitaus größte Teil des Textes ist aber für alle Controller der AVR-Familie gültig. 
</li>
</ul>
<dl>
<dd>Brauchbare Testplattformen sind auch das <a href="http://www.mikrocontroller.net/articles/STK500" title="STK500">STK500</a> und der <a href="http://www.mikrocontroller.net/articles/AVR_Butterfly" title="AVR Butterfly">AVR Butterfly</a> von Atmel. Weitere Infos findet man in den Artikeln <a href="http://www.mikrocontroller.net/articles/AVR#Starterkits" title="AVR">AVR Starterkits</a> und <a href="http://www.mikrocontroller.net/articles/AVR-Tutorial:_Equipment" title="AVR-Tutorial: Equipment">AVR-Tutorial: Equipment</a>.
</dd>
</dl>
<ul>
<li> Programmiersoftware und -<a href="http://www.mikrocontroller.net/articles/AVR_In_System_Programmer" title="AVR In System Programmer">hardware</a> z. B. PonyProg (siehe auch: <a href="http://www.mikrocontroller.net/articles/Pony-Prog_Tutorial" title="Pony-Prog Tutorial">Pony-Prog Tutorial</a>) oder <a href="http://www.mikrocontroller.net/articles/AVRDUDE" title="AVRDUDE">AVRDUDE</a> mit <a href="http://www.mikrocontroller.net/articles/STK200" title="STK200">STK200</a>-Dongle oder die von Atmel verfügbare Hard- und Software (<a href="http://www.mikrocontroller.net/articles/STK500" title="STK500">STK500</a>, Atmel AVRISP, <a href="http://www.mikrocontroller.net/articles/AVR-Studio" title="AVR-Studio" class="mw-redirect">AVR-Studio</a>).
</li>
</ul>
<ul>
<li> Nicht unbedingt erforderlich, aber zur Simulation und zum Debuggen unter MS-Windows recht nützlich: <a href="http://www.mikrocontroller.net/articles/AVR-Studio" title="AVR-Studio" class="mw-redirect">AVR-Studio</a>.
</li>
</ul>
<ul>
<li> Wer unter Windows und Linux gleichermassen entwickeln will, der sollte sich die <a rel="nofollow" class="external text" href="http://www.eclipse.org/">IDE Eclipse for C/C++ Developers</a> und das <a rel="nofollow" class="external text" href="http://avr-eclipse.sourceforge.net/wiki/index.php/The_AVR_Eclipse_Plugin">AVR-Eclipse Plugin</a> ansehen. Beide sind unter Windows und Linux einfach zu installieren, siehe auch <a href="http://www.mikrocontroller.net/articles/AVR_Eclipse" title="AVR Eclipse">AVR Eclipse</a>. Ebenfalls unter Linux und Windows verfügbar ist die Entwicklungsumgebung <a rel="nofollow" class="external text" href="http://www.codeblocks.org/">Code::Blocks</a><sup id="cite_ref-2" class="reference"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#cite_note-2">[2]</a></sup>. Innerhalb dieser Entwicklungsumgebung können ohne die Installation zusätzlicher Plugins "AVR-Projekte" angelegt werden. Für Linux gibt es auch noch das <a rel="nofollow" class="external text" href="http://www.roboternetz.de/phpBB2/zeigebeitrag.php?t=25220">KontrollerLab</a>.
</li>
</ul>
<h1><span class="mw-headline" id="Was_tun.2C_wenn.27s_nicht_klappt.3F">Was tun, wenn's nicht klappt?</span></h1>
<ul>
<li> Herausfinden, ob es tatsächlich ein avr(-gcc) spezifisches Problem ist oder nur die eigenen C-Kenntnisse einer Auffrischung bedürfen. Allgemeine C-Fragen kann man eventuell "beim freundlichen Programmierer zwei Büro-, Zimmer- oder Haustüren weiter" loswerden. Ansonsten: <a href="http://www.mikrocontroller.net/articles/C" title="C">C</a>-Buch (gibt's auch "gratis" online) lesen.
</li>
</ul>
<ul>
<li> Die <a href="http://www.mikrocontroller.net/articles/AVR_Checkliste" title="AVR Checkliste">AVR Checkliste</a> durcharbeiten.
</li>
</ul>
<ul>
<li> Die <b><a rel="nofollow" class="external text" href="http://www.nongnu.org/avr-libc/user-manual/index.html">Dokumentation der avr-libc</a></b> lesen, vor allem (aber nicht nur) den Abschnitt Related Pages/<b>Frequently Asked Questions</b> = Oft gestellte Fragen (und Antworten dazu). Z.Zt leider nur in englischer Sprache verfügbar.
</li>
</ul>
<ul>
<li> Den Artikel <a href="http://www.mikrocontroller.net/articles/AVR-GCC" title="AVR-GCC">AVR-GCC</a> in diesem Wiki lesen.
</li>
</ul>
<ul>
<li> Das <a class="external text" href="http://www.mikrocontroller.net/forum/gcc">GCC-Forum auf  www.mikrocontroller.net</a> nach vergleichbaren Problemen absuchen.
</li>
</ul>
<ul>
<li> Das avr-gcc-Forum bei <a rel="nofollow" class="external text" href="http://www.avrfreaks.net/">AVRfreaks</a> nach vergleichbaren Problemen absuchen.
</li>
</ul>
<ul>
<li> Das <a rel="nofollow" class="external text" href="http://lists.gnu.org/archive/html/avr-gcc-list/">Archiv der avr-gcc Mailing-Liste</a> nach vergleichbaren Problemen absuchen.
</li>
</ul>
<ul>
<li> Nach Beispielcode suchen. Vor allem im <i>Projects</i>-Bereich von <a rel="nofollow" class="external text" href="http://www.avrfreaks.net/">AVRfreaks</a> (anmelden).
</li>
</ul>
<ul>
<li> Google oder yahoo befragen schadet nie.
</li>
</ul>
<ul>
<li> Bei Problemen mit der Ansteuerung interner AVR-Funktionen mit C-Code: das Datenblatt des Controllers lesen (ganz und am Besten zweimal). Datenblätter sind  auf den <a rel="nofollow" class="external text" href="http://www.atmel.com/">Atmel Webseiten</a> als pdf-Dateien verfügbar. Das komplette Datenblatt (complete) und nicht die Kurzfassung (summary) verwenden.
</li>
</ul>
<ul>
<li> Die Beispielprogramme im <a href="http://www.mikrocontroller.net/articles/AVR-Tutorial" title="AVR-Tutorial">AVR-Tutorial</a> sind zwar in AVR-Assembler verfasst, Erläuterungen und Vorgehensweisen sind aber auch auf C-Programme übertragbar.
</li>
</ul>
<ul>
<li> Einen Beitrag in eines der Foren oder eine Mail an die Mailing-Liste schreiben. Dabei möglichst viel Information geben: Controller, Compilerversion, genutzte Bibliotheken, Ausschnitte aus dem Quellcode oder besser ein <a class="external text" href="http://www.mikrocontroller.net/topic/72767#598986">Testprojekt</a> mit allen notwendigen Dateien, um das Problem nachzuvollziehen, sowie genaue Fehlermeldungen bzw. Beschreibung des Fehlverhaltens. Bei Ansteuerung externer Geräte die Beschaltung beschreiben oder skizzieren (z. B. mit <a rel="nofollow" class="external text" href="http://www.tech-chat.de/">Andys ASCII Circuit</a>). Siehe dazu auch: <b><a rel="nofollow" class="external text" href="http://www.tty1.net/smart-questions_de.html">"Wie man Fragen richtig stellt"</a></b>.
</li>
</ul>
<h1><span class="mw-headline" id="Erzeugen_von_Maschinencode">Erzeugen von Maschinencode</span></h1>
<p>Aus dem C-Quellcode erzeugt der avr-gcc Compiler (zusammen mit Hilfsprogrammen wie z.&nbsp;B. Präprozessor, Assembler und Linker) Maschinencode für den AVR-Controller. Üblicherweise liegt dieser Code dann im Intel Hex-Format vor ("Hex-Datei"). Die Programmiersoftware (z.&nbsp;B. <a href="http://www.mikrocontroller.net/articles/AVRDUDE" title="AVRDUDE">AVRDUDE</a>, PonyProg oder AVRStudio/STK500-plugin) liest diese Datei ein und überträgt die enthaltene Information (den Maschinencode) in den Speicher des Controllers. Im Prinzip sind also "nur" der avr-gcc-Compiler (und wenige Hilfsprogramme) mit den "richtigen" Optionen aufzurufen, um aus C-Code eine "Hex-Datei" zu erzeugen. Grundsätzlich stehen dazu drei verschiedene Ansätze zur Verfügung:
</p>
<ul>
<li> Die Verwendung einer integrierten Entwicklungsumgebung (IDE = <b>I</b>ntegrated <b>D</b>evelopment <b>E</b>nvironment), bei der alle Einstellungen z.&nbsp;B. in Dialogboxen durchgeführt werden können. Unter Anderem kann AVRStudio ab Version 4.12 (kostenlos auf <a rel="nofollow" class="external text" href="http://www.atmel.com/">atmel.com</a>) zusammen mit WinAVR als integrierte Entwicklungsumgebung für den Compiler avr-gcc genutzt werden (dazu müssen AVRStudio und WinAVR auf dem Rechner installiert sein). Weitere IDEs (ohne Anspruch auf Vollständigkeit): <a rel="nofollow" class="external text" href="http://www.eclipse.org/">Eclipse for C/C++ Developers</a> (d.h. inkl. CDT) und das <a rel="nofollow" class="external text" href="http://avr-eclipse.sourceforge.net/wiki/index.php/The_AVR_Eclipse_Plugin">AVR-Eclipse Plugin</a> (für diverse Plattformen, u.a. Linux und MS Windows, IDE und Plugin kostenlos), <a rel="nofollow" class="external text" href="http://sourceforge.net/projects/kontrollerlab">KontrollerLab</a> (Linux/KDE, kostenlos). <a rel="nofollow" class="external text" href="http://www.atmanecl.com/EnglishSite/SoftwareEnglish.htm">AtmanAvr</a> (MS Windows, relativ günstig), KamAVR (MS-Windows, kostenlos, wird augenscheinlich nicht mehr weiterentwickelt), <a rel="nofollow" class="external text" href="http://www.amctools.com/vmlab.htm">VMLab</a> (MS Windows, ab Version 3.12 ebenfalls kostenlos). Integrierte Entwicklungsumgebungen unterscheiden sich stark in Ihrer Bedienung und stehen auch nicht für alle Plattformen zur Verfügung, auf denen der Compiler  ausführbar ist (z.&nbsp;B. AVRStudio nur für MS-Windows). Zur Anwendung des avr-gcc Compilers mit IDEs sei hier auf deren Dokumentation verwiesen. 
</li>
</ul>
<ul>
<li> Die Nutzung des Programms make mit passenden Makefiles. In den folgenden Abschnitten wird die Generierung von Maschinencode für einen AVR ("hex-Datei") aus C-Quellcode ("c-Dateien") anhand von "make" und den "Makefiles" näher erläutert. Viele der darin beschriebenen Optionen findet man auch im Konfigurationsdialog des avr-gcc-Plugins von AVRStudio (AVRStudio generiert ein makefile in einem Unterverzeichnis des Projektverzeichnisses). 
</li>
</ul>
<ul>
<li> Das Generieren des Programms ohne IDE und ohne Makefile. In diesem Fall muss die Quellcodedatei durch eine vorgefertigte Kommandofolge an den Compiler übergeben werden. Der Artikel <a href="http://www.mikrocontroller.net/articles/C_ohne_Makefile" title="C ohne Makefile">C ohne Makefile</a> zeigt, wie das funktioniert. Diese Vorgehensweise empfiehlt sich jedoch nur für kleine Programme, die nicht auf verschiedene Quellcodedateien verteilt sind.
</li>
</ul>
<p>Beim Wechsel vom makefile-Ansatz nach WinAVR-Vorlage zu AVRStudio ist darauf zu achten, dass AVRStudio (Stand: AVRStudio Version 4.13) bei einem neuen Projekt die Optimierungsoption (vgl. Artikel <a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial/Exkurs_Makefiles" title="AVR-GCC-Tutorial/Exkurs Makefiles">AVR-GCC-Tutorial/Exkurs: Makefiles</a>, typisch: -Os) nicht einstellt und die mathematische Bibliothek der avr-libc (libm.a, Linker-Option -lm) nicht einbindet. (Hinweis: Bei Version 4.16 wird beides bereits gesetzt). Beides ist Standard bei Verwendung von makefiles nach WinAVR-Vorlage und sollte daher auch im Konfigurationsdialog des avr-gcc-Plugins von AVRStudio "manuell" eingestellt werden, um auch mit AVRStudio kompakten Code zu erzeugen.
</p>
<h1><span class="mw-headline" id="Einf.C3.BChrungsbeispiel">Einführungsbeispiel</span></h1>
<p>Zum Einstieg ein kleines Beispiel, an dem die Nutzung des Compilers und der Hilfsprogramme (der sogenannten <i>Toolchain</i>) demonstriert wird. Detaillierte Erläuterungen folgen in den weiteren Abschnitten dieses Tutorials.
</p><p>Das Programm soll auf einem AVR Mikrocontroller einige Ausgänge ein- und andere ausschalten. Das Beispiel ist für einen ATmega16 programmiert (<a rel="nofollow" class="external text" href="http://www.atmel.com/dyn/resources/prod_documents/doc2466.pdf">Datenblatt</a>), kann aber sinngemäß für andere Controller der AVR-Familie modifiziert werden. 
</p><p>Ein kurzes Wort zur Hardware: Bei diesem Programm werden alle Pins von PORTB auf Ausgang gesetzt, und einige davon werden auf HIGH andere auf LOW gesetzt. Das kann je nach angeschlossener Hardware an diesen Pins kritisch sein. Am ungefährlichsten ist es, wenn nichts an den Pins angeschlossen ist und man die Funktion des Programmes durch eine Spannungsmessung mit einem Multimeter kontrolliert. Die Spannung wird dabei zwischen GND-Pin und den einzelnen Pins von PORTB gemessen.
</p><p>Zunächst der Quellcode der Anwendung, der in einer Text-Datei mit dem Namen <i>main.c</i> abgespeichert wird.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="coMULTI">/* Alle Zeichen zwischen Schrägstrich-Stern 
   und Stern-Schrägstrich sind Kommentare */</span>
&nbsp;
<span class="co1">// Zeilenkommentare sind ebenfalls möglich</span>
<span class="co1">// alle auf die beiden Schrägstriche folgenden</span>
<span class="co1">// Zeichen einer Zeile sind Kommentar</span>
&nbsp;
<span class="co2">#include &lt;avr/io.h&gt;          // (1)</span>
&nbsp;
<span class="kw4">int</span> main <span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span> <span class="br0">{</span>            <span class="co1">// (2)</span>
&nbsp;
   DDRB  <span class="sy0">=</span> <span class="nu12">0xFF</span><span class="sy0">;</span>             <span class="co1">// (3)</span>
   PORTB <span class="sy0">=</span> <span class="nu12">0x03</span><span class="sy0">;</span>             <span class="co1">// (4)</span>
&nbsp;
   <span class="kw1">while</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span> <span class="br0">{</span>                <span class="co1">// (5)</span>
     <span class="coMULTI">/* "leere" Schleife*/</span>   <span class="co1">// (6)</span>
   <span class="br0">}</span>                         <span class="co1">// (7)</span>
&nbsp;
   <span class="coMULTI">/* wird nie erreicht */</span>
   <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>                 <span class="co1">// (8)</span>
<span class="br0">}</span></pre></div></div>
<ol>
<li> In dieser Zeile wird eine sogenannte Header-Datei eingebunden. In <code>avr/io.h</code> sind die Registernamen definiert, die im späteren Verlauf genutzt werden. Auch unter Windows wird ein&nbsp;<code>/</code> zur Kennzeichnung von Unterverzeichnissen in Include-Dateinamen verwendet und kein&nbsp;<code>\</code>.
</li>
<li> Hier beginnt das eigentliche Programm. Jedes C-Programm beginnt mit den Anweisungen in der Funktion <code>main</code>.
</li>
<li> Die Anschlüsse eines AVR (Pins) werden zu Blöcken zusammengefasst, einen solchen Block bezeichnet man als Port. Beim ATmega16 hat jeder Port 8 Anschlüsse, bei kleineren AVRs können einem Port auch weniger als 8 Anschlüsse zugeordnet sein. Da per Definition (Datenblatt) alle gesetzten Bits in einem Datenrichtungsregister den entsprechenden Anschluss auf Ausgang schalten, werden mit DDRB=0xff alle Anschlüsse des Ports B als Ausgänge eingestellt.
</li>
<li> Die den ersten beiden Bits des Ports zugeordneten Anschlüsse (PB0 und PB1) werden 1, alle anderen Anschlüsse des Ports B (PB2-PB7) zu 0. Aktivierte Ausgänge (logisch 1 oder "high") liegen auf Betriebsspannung (VCC, meist 5 Volt), nicht aktivierte Ausgänge führen 0 Volt (GND, Bezugspotential). Es ist sinnvoll, sich möglichst frühzeitig eine alternative Schreibweise beizubringen, die wegen der leichteren Überprüfbarkeit und Portierbarkeit oft im weiteren Tutorial und in Forenbeiträgen benutzt wird. Die Zuordnung sieht in diesem Fall so aus, Näheres dazu im Artikel <a href="http://www.mikrocontroller.net/articles/Bitmanipulation" title="Bitmanipulation">Bitmanipulation</a>:<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1">PORTB <span class="sy0">=</span> <span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>PB1<span class="br0">)</span> <span class="sy0">|</span> <span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>PB0<span class="br0">)</span><span class="sy0">;</span></pre></div></div>
</li>
<li> ist der Beginn der sogenannte <i>Hauptschleife</i> (main-loop). Dies ist eine Endlosschleife, welche kontinuierlich wiederkehrende Befehle enthält.
</li>
<li> In diesem Beispiel ist die Hauptschleife leer. Der Controller durchläuft die Schleife immer wieder, ohne dass etwas passiert. Eine solche Schleife ist notwendig, da es auf dem Controller kein Betriebssystem gibt, das nach Beendigung des Programmes die Kontrolle übernehmen könnte. Ohne diese Schleife kehrt das Programm aus <code>main</code> zurück, alle Interrupts werden deaktiviert und eine Endlosschleife betreten.
</li>
<li> Ende der Hauptschleife und Sprung zur passenden, öffnenden Klammer, also zu 5.
</li>
<li> ist das Programmende. Die Zeile ist nur aus Gründen der C-Kompatibilität enthalten: <div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> main<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span></pre></div></div> besagt, dass die Funktion einen int-Wert zurückgibt. Die Anweisung wird aber nicht erreicht, da das Programm die Hauptschleife nie verlässt.
</li>
</ol>
<p>Um diesen Quellcode in ein lauffähiges Programm zu übersetzen, wird hier ein Makefile genutzt. Das verwendete Makefile findet sich auf der Seite <a href="http://www.mikrocontroller.net/articles/Beispiel_Makefile" title="Beispiel Makefile">Beispiel Makefile</a> und basiert auf der Vorlage, die in WinAVR mitgeliefert wird und wurde bereits angepasst (Controllertyp ATmega16). Man kann das Makefile bearbeiten und an andere Controller anpassen oder sich mit dem Programm MFile menügesteuert ein Makefile "zusammenklicken". Das Makefile speichert man unter dem Namen <code>Makefile</code> (ohne Endung) im selben Verzeichnis, in dem auch die Datei <code>main.c</code> mit dem Programmcode abgelegt ist. Detailliertere Erklärungen zur Funktion von Makefiles finden sich im Artikel <a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial/Exkurs_Makefiles" title="AVR-GCC-Tutorial/Exkurs Makefiles">Exkurs: Makefiles</a>.
</p>
<pre>D:\beispiel&gt;dir

 Verzeichnis von D:\beispiel

28.11.2006  22:53    &lt;DIR&gt;          .
28.11.2006  22:53    &lt;DIR&gt;          ..
28.11.2006  20:06               118 main.c
28.11.2006  20:03            16.810 Makefile
               2 Datei(en)         16.928 Bytes
</pre>
<p>Nun gibt man <i>make all</i> ein. Falls das mit WinAVR installierte Programmers Notepad genutzt wird, gibt es dazu einen Menüpunkt im Tools Menü. Sind alle Einstellungen korrekt, entsteht eine Datei <code>main.hex</code>, in welcher der Code für den AVR enthalten ist. 
</p>
<pre>D:\beispiel&gt;make all

-------- begin --------
avr-gcc (GCC) 3.4.6
Copyright (C) 2006 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

Compiling C: main.c
avr-gcc -c -mmcu=atmega16 -I. -gdwarf-2 -DF_CPU=1000000UL -Os -funsigned-char -f
unsigned-bitfields -fpack-struct -fshort-enums -Wall -Wstrict-prototypes -Wundef
 -Wa,-adhlns=obj/main.lst  -std=gnu99 -Wundef -MD -MP -MF .dep/main.o.d main.c -
o obj/main.o

Linking: main.elf
avr-gcc -mmcu=atmega16 -I. -gdwarf-2 -DF_CPU=1000000UL -Os -funsigned-char -funs
igned-bitfields -fpack-struct -fshort-enums -Wall -Wstrict-prototypes -Wundef -W
a,-adhlns=obj/main.o  -std=gnu99 -Wundef -MD -MP -MF .dep/main.elf.d obj/main.o
--output main.elf -Wl,-Map=main.map,--cref    -lm

Creating load file for Flash: main.hex
avr-objcopy -O ihex -R .eeprom main.elf main.hex
</pre>
<p>Der Inhalt der hex-Datei kann nun zum Controller übertragen werden. Dies kann z.&nbsp;B. über In-System-Programming (<a href="http://www.mikrocontroller.net/articles/ISP" title="ISP">ISP</a>) erfolgen, das im <a href="http://www.mikrocontroller.net/articles/AVR-Tutorial:_Equipment" title="AVR-Tutorial: Equipment">AVR-Tutorial: Equipment</a> beschrieben ist. Makefiles nach der WinAVR/MFile-Vorlage sind für die Nutzung des Programms <a href="http://www.mikrocontroller.net/articles/AVRDUDE" title="AVRDUDE">AVRDUDE</a> vorbereitet. Wenn man den Typ und Anschluss des Programmiergerätes richtig eingestellt hat, kann mit <i>make program</i> die Übertragung mittels AVRDUDE gestartet werden. Jede andere Software, die hex-Dateien lesen und zu einem AVR übertragen kann<sup id="cite_ref-3" class="reference"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#cite_note-3">[3]</a></sup>, kann natürlich ebenfalls genutzt werden.
</p><p>Startet man nun den Controller (Reset-Taster oder Stromzufuhr aus/an), werden vom Programm die Anschlüsse PB0 und PB1 auf 1 gesetzt. Man kann mit einem Messgerät nun an diesem Anschluss die Betriebsspannung messen oder eine <a href="http://www.mikrocontroller.net/articles/LED" title="LED">LED</a> leuchten lassen (Anode an den Pin, Vorwiderstand nicht vergessen). An den Anschlüssen PB2-PB7 misst man 0 Volt. Eine mit der Anode mit einem dieser Anschlüsse verbundene LED leuchtet nicht.
</p>
<h1><span class="mw-headline" id="Ganzzahlige_Datentypen_.28Integer.29">Ganzzahlige Datentypen (Integer)</span></h1>
<p>Bei der Programmierung von Mikrokontrollern ist die Definition einiger ganzzahliger Datentypen sinnvoll, an denen eindeutig die Bit-Länge abgelesen werden kann.
</p><p>Standardisierte Datentypen werden in der Header-Datei <code>stdint.h</code> definiert, die folgendermaßen eingebunden werden kann:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;stdint.h&gt;</span></pre></div></div>
<table border="1" cellpadding="4" style="margin: 1em 1em 1em 0; background: #f9f9f9; border: 1px #AAA solid; border-collapse: collapse; empty-cells:show; {{{1}}} }">
<caption> <b>int-Typen aus <code>stdint.h</code> (C99)</b><br>&nbsp;
</caption>
<tbody><tr bgcolor="#d0d0ff">
<th colspan="5"> Vorzeichenbehaftete int-Typen
</th></tr>
<tr bgcolor="#e8e8ff">
<th> Typname </th>
<th> Bit-Breite </th>
<th colspan="2"> Wertebereich
</th>
<td> <b>C-Entsprechung</b> (avr-gcc)
</td></tr>
<tr>
<td><code>int8_t</code> </td>
<td align="right"> 8 </td>
<td> −128 ⋯ 127 </td>
<td> −2<sup>7</sup> ⋯ 2<sup>7</sup>−1 </td>
<td> <code>signed char</code>
</td></tr>
<tr>
<td><code>int16_t</code> </td>
<td align="right"> 16 </td>
<td> −32768 ⋯ 32767 </td>
<td> −2<sup>15</sup> ⋯ 2<sup>15</sup>−1 </td>
<td> <code>signed short</code>, <code>signed int</code>
</td></tr>
<tr>
<td><code>int32_t</code> </td>
<td align="right"> 32 </td>
<td> −2147483648 ⋯ 2147483647 </td>
<td> −2<sup>31</sup> ⋯ 2<sup>31</sup>−1 </td>
<td> <code>signed long</code>
</td></tr>
<tr>
<td><code>int64_t</code> </td>
<td align="right"> 64 </td>
<td> −9223372036854775808 ⋯ 9223372036854775807 </td>
<td> −2<sup>63</sup> ⋯ 2<sup>63</sup>−1 </td>
<td> <code>signed long long</code>
</td></tr>
<tr bgcolor="#d0d0ff">
<th colspan="5"> Vorzeichenlose int-Typen
</th></tr>
<tr bgcolor="#e8e8ff">
<th> Typname </th>
<th> Bit-Breite </th>
<th colspan="2"> Wertebereich
</th>
<td> <b>C-Entsprechung</b> (avr-gcc)
</td></tr>
<tr>
<td><code>uint8_t</code> </td>
<td align="right"> 8 </td>
<td> 0 ⋯ 255 </td>
<td> 0 ⋯ 2<sup>8</sup>−1 </td>
<td> <code>unsigned char</code>
</td></tr>
<tr>
<td><code>uint16_t</code> </td>
<td align="right"> 16 </td>
<td> 0 ⋯ 65535 </td>
<td> 0 ⋯ 2<sup>16</sup>−1 </td>
<td> <code>unsigned short</code>, <code>unsigned int</code>
</td></tr>
<tr>
<td><code>uint32_t</code> </td>
<td align="right"> 32 </td>
<td> 0 ⋯ 4294967295 </td>
<td> 0 ⋯ 2<sup>32</sup>−1 </td>
<td> <code>unsigned long</code>
</td></tr>
<tr>
<td><code>uint64_t</code> </td>
<td align="right"> 64 </td>
<td> 0 ⋯ 18446744073709551615 </td>
<td> 0 ⋯ 2<sup>64</sup>−1 </td>
<td> <code>unsigned long long</code>
</td></tr></tbody></table>
<p>Neben den Typen gibt es auch Makros für die Bereichsgrenzen wie <code>INT8_MIN</code> oder <code>UINT16_MAX</code>. Siehe dazu auch: <a rel="nofollow" class="external text" href="http://www.nongnu.org/avr-libc/user-manual/group__avr__stdint.html">Dokumentation der avr-libc: Standard Integer Types</a>.
</p>
<h1><span class="mw-headline" id="Grunds.C3.A4tzlicher_Programmaufbau_eines_.C2.B5C-Programms">Grundsätzlicher Programmaufbau eines µC-Programms</span></h1>
<p>Wir unterscheiden zwischen 2 verschiedenen Methoden, um ein
Mikrocontroller-Programm zu schreiben, und zwar völlig unabhängig davon, in
welcher Programmiersprache das Programm geschrieben wird.
</p>
<h2><span class="mw-headline" id="Sequentieller_Programmablauf">Sequentieller Programmablauf</span></h2>
<div class="floatleft"><a href="http://www.mikrocontroller.net/articles/Datei:Sequentielle_Programme.gif" class="image"><img alt="Sequentielle Programme.gif" src="./AVR-GCC-Tutorial - Mikrocontroller.net_files/Sequentielle_Programme.gif" width="180" height="240"></a></div>
<p>Bei dieser Programmiertechnik wird eine Endlosschleife programmiert, welche im
Wesentlichen immer den gleichen Aufbau hat. Es wird hier nach dem sogenannten EVA-Prinzip gehandelt. EVA steht für "Eingabe, Verarbeitung, Ausgabe".
</p>
<hr style="visibility:hidden;clear:both;">
<h2><span class="mw-headline" id="Interruptgesteuerter_Programmablauf">Interruptgesteuerter Programmablauf</span></h2>
<div class="floatleft"><a href="http://www.mikrocontroller.net/articles/Datei:Interrupt_Programme.gif" class="image"><img alt="Interrupt Programme.gif" src="./AVR-GCC-Tutorial - Mikrocontroller.net_files/Interrupt_Programme.gif" width="360" height="240"></a></div>
<p>Bei dieser Methode werden beim Programmstart zuerst die gewünschten Interruptquellen aktiviert und dann in eine Endlosschleife gegangen, in welcher Dinge erledigt werden können, welche nicht zeitkritisch sind. Wenn ein Interrupt ausgelöst wird, so wird automatisch die zugeordnete Interruptfunktion ausgeführt.
</p>
<hr style="visibility:hidden;clear:both;">
<h1><span class="mw-headline" id="Zugriff_auf_Register">Zugriff auf Register</span></h1>
<p>Die AVR-Controller verfügen über eine Vielzahl von Registern. Die meisten
davon sind sogenannte Schreib-/Leseregister. Das heißt, das Programm kann die
Inhalte der Register sowohl auslesen als auch beschreiben.
</p><p>Register haben einen besonderen Stellenwert bei den AVR Controllern. Sie dienen dem Zugriff auf die Ports und die Schnittstellen des Controllers. Wir unterscheiden zwischen 8-Bit und 16-Bit Registern. Vorerst behandeln wir die 8-Bit Register.
</p><p>Einzelne Register sind bei allen AVRs vorhanden, andere wiederum nur bei bestimmten Typen. So sind beispielsweise die Register, welche für den Zugriff auf den UART notwendig sind, selbstverständlich nur bei denjenigen Modellen vorhanden, welche über einen integrierten Hardware UART bzw. USART verfügen.
</p><p>Die Namen der Register sind in den Headerdateien zu den entsprechenden AVR-Typen definiert. Dazu muss man den Namen der controllerspezifischen Headerdatei nicht kennen. Es reicht aus, die allgemeine Headerdatei <i>avr/io.h</i> einzubinden:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/io.h&gt;</span></pre></div></div>
<p>Ist im Makefile der MCU-Typ z.&nbsp;B. mit dem Inhalt atmega8 definiert (und wird somit per -mmcu=atmega8 an den Compiler übergeben), wird beim Einlesen der io.h-Datei implizit ("automatisch") auch die iom8.h-Datei mit den Register-Definitionen für den ATmega8 eingelesen.
</p><p>Intern wird diese "Automatik" wie folgt realisiert: Der Controllertyp wird dem Compiler als Parameter übergeben (vgl. <i>avr-gcc -c -mmcu=atmega16 [...]</i> im Einführungsbeispiel). Wird ein Makefile nach der WinAVR/mfile-Vorlage verwendet, setzt man die Variable <i>MCU</i>, der Inhalt dieser Variable wird dann an passender Stelle für die Compilerparameter verwendet. Der Compiler definiert intern eine dem mmcu-Parameter zugeordnete "Variable" (genauer: ein Makro) mit dem Namen des Controllers, vorangestelltem <i>__AVR_</i> und angehängten Unterstrichen (z.&nbsp;B. wird bei <i>-mmcu=atmega16</i> das Makro <i>__AVR_ATmega16__</i> definiert). Beim Einbinden der Header-Datei <i>avr/io.h</i> wird geprüft, ob das jeweilige Makro definiert ist und die zum Controller passende Definitionsdatei eingelesen. Zur Veranschaulichung einige Ausschnitte aus einem Makefile:
</p>
<pre>[...]
# MCU Type ("name") setzen:
MCU = atmega16
[...]

[...]
## Verwendung des Inhalts von MCU (hier atmega16) fuer die 
## Compiler- und Assembler-Parameter
ALL_CFLAGS = -mmcu=$(MCU) -I. $(CFLAGS) $(GENDEPFLAGS)
ALL_CPPFLAGS = -mmcu=$(MCU) -I. -x c++ $(CPPFLAGS) $(GENDEPFLAGS)
ALL_ASFLAGS = -mmcu=$(MCU) -I. -x assembler-with-cpp $(ASFLAGS)
[...]

[...]
## Aufruf des Compilers:
## mit den Parametern ($(ALL_CFLAGS) ist -mmcu=$(MCU)[...] = -mmcu=atmega16[...]
$(OBJDIR)/%.o&nbsp;:&nbsp;%.c
	@echo
	@echo $(MSG_COMPILING) $&lt;
	$(CC) -c $(ALL_CFLAGS) $&lt; -o $@ 
[...]
</pre>
<p>Da --mmcu=atmega16 übergeben wurde, wird __AVR_ATmega16__ definiert und kann in avr/io.h zur Fallunterscheidung genutzt werden:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co1">// avr/io.h </span>
<span class="co1">// (bei WinAVR-Standardinstallation in C:\WinAVR\avr\include\avr)</span>
<span class="br0">[</span>...<span class="br0">]</span>
<span class="co2">#if defined (__AVR_AT94K__)</span>
<span class="co2">#  include &lt;avr/ioat94k.h&gt;</span>
<span class="co1">// [...]</span>
<span class="co2">#elif defined (__AVR_ATmega16__)</span>
<span class="co1">// da __AVR_ATmega16__ definiert ist, wird avr/iom16.h eingebunden:</span>
<span class="co2">#  include &lt;avr/iom16.h&gt;</span>
<span class="co1">// [...]</span>
<span class="co2">#else</span>
<span class="co2">#  if&nbsp;!defined(__COMPILING_AVR_LIBC__)</span>
<span class="co2">#    warning "device type not defined"</span>
<span class="co2">#  endif</span>
<span class="co2">#endif</span></pre></div></div>
<p>Die Beispiele in den folgenden Abschnitten demonstrieren den Zugriff auf Register anhand der Register für I/O-Ports (PORTx, DDRx, PINx), die Vorgehensweise ist jedoch für alle Register (z.&nbsp;B. die des UART, ADC, SPI) analog.
</p>
<h2><span class="mw-headline" id="Schreiben_in_Register">Schreiben in Register</span></h2>
<p>Zum Schreiben kann man Register einfach wie eine Variable setzen.<sup id="cite_ref-4" class="reference"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#cite_note-4">[4]</a></sup>
</p><p>Beispiel:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/io.h&gt;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="coMULTI">/* Setzt das Richtungsregister des Ports A auf 0xff 
       (alle Pins als Ausgang, vgl. Abschnitt Zugriff auf Ports): */</span>
    DDRA <span class="sy0">=</span> <span class="nu12">0xff</span><span class="sy0">;</span>    
&nbsp;
    <span class="coMULTI">/* Setzt PortA auf 0x03, Bit 0 und 1 "high", restliche "low": */</span>
    PORTA <span class="sy0">=</span> <span class="nu12">0x03</span><span class="sy0">;</span>   
&nbsp;
    <span class="co1">// Setzen der Bits 0,1,2,3 und 4</span>
    <span class="co1">// Binär 00011111 = Hexadezimal 1F</span>
    DDRB <span class="sy0">=</span> <span class="nu12">0x1F</span><span class="sy0">;</span>    <span class="coMULTI">/* direkte Zuweisung - unübersichtlich */</span>
&nbsp;
    <span class="coMULTI">/* Ausführliche Schreibweise: identische Funktionalität, mehr Tipparbeit
       aber übersichtlicher und selbsterklärend: */</span>
    DDRB <span class="sy0">=</span> <span class="br0">(</span><span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> DDB0<span class="br0">)</span> <span class="sy0">|</span> <span class="br0">(</span><span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> DDB1<span class="br0">)</span> <span class="sy0">|</span> <span class="br0">(</span><span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> DDB2<span class="br0">)</span> <span class="sy0">|</span> <span class="br0">(</span><span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> DDB3<span class="br0">)</span> <span class="sy0">|</span> <span class="br0">(</span><span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> DDB4<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="kw1">while</span> <span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<p>Die ausführliche Schreibweise sollte bevorzugt verwendet werden, da dadurch die Zuweisungen selbsterklärend sind und somit der Code leichter nachvollzogen werden kann. Atmel verwendet sie auch bei Beispielen in Datenblätten und in den allermeisten Quellcodes zu Application-Notes. Mehr zu der Schreibweise mit "|" und "&lt;&lt;" findet man unter <a href="http://www.mikrocontroller.net/articles/Bitmanipulation" title="Bitmanipulation">Bitmanipulation</a>.
</p><p>Der gcc C-Compiler unterstützt ab Version 4.3.0 Konstanten im Binärformat, z.&nbsp;B. DDRB&nbsp;=&nbsp;0b00011111. Diese Schreibweise ist jedoch nur in GNU-C verfügbar und nicht in ISO-C definiert. Man sollte sie daher nicht verwenden, wenn Code mit anderen ausgetauscht oder mit anderen Compilern bzw. älteren Versionen des gcc genutzt werden soll.
</p>
<h2><span class="mw-headline" id="Ver.C3.A4ndern_von_Registerinhalten">Verändern von Registerinhalten</span></h2>
<p>Einzelne Bits setzt und löscht man "Standard-C-konform" mittels logischer (Bit-) Operationen. 
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"> x <span class="sy0">|=</span> <span class="br0">(</span><span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> Bitnummer<span class="br0">)</span><span class="sy0">;</span>  <span class="co1">// Hiermit wird ein Bit in x gesetzt</span>
 x <span class="sy0">&amp;=</span> ~<span class="br0">(</span><span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> Bitnummer<span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Hiermit wird ein Bit in x geloescht</span></pre></div></div>
<p>Es wird jeweils nur der Zustand des angegebenen Bits geändert, der vorherige Zustand der anderen Bits bleibt erhalten. 
</p><p>Beispiel:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/io.h&gt;</span>
...
<span class="co2">#define MEINBIT 2</span>
...
<span class="me1">PORTA</span> <span class="sy0">|=</span> <span class="br0">(</span><span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> MEINBIT<span class="br0">)</span><span class="sy0">;</span>    <span class="coMULTI">/* setzt Bit 2 an PortA auf 1 */</span>
PORTA <span class="sy0">&amp;=</span> ~<span class="br0">(</span><span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> MEINBIT<span class="br0">)</span><span class="sy0">;</span>   <span class="coMULTI">/* loescht Bit 2 an PortA */</span></pre></div></div>
<p>Mit dieser Methode lassen sich auch mehrere Bits eines Registers gleichzeitig setzen und löschen.
</p><p>Beispiel:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/io.h&gt;</span>
...
<span class="me1">DDRA</span> <span class="sy0">&amp;=</span> ~<span class="br0">(</span> <span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>PA0<span class="br0">)</span> <span class="sy0">|</span> <span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>PA3<span class="br0">)</span> <span class="br0">)</span><span class="sy0">;</span>  <span class="coMULTI">/* PA0 und PA3 als Eingaenge */</span>
PORTA <span class="sy0">|=</span> <span class="br0">(</span> <span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>PA0<span class="br0">)</span> <span class="sy0">|</span> <span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>PA3<span class="br0">)</span> <span class="br0">)</span><span class="sy0">;</span>  <span class="coMULTI">/* Interne Pull-Up fuer beide einschalten */</span></pre></div></div>
<p>Bei bestimmten AVR Registern mit Bits, die durch Beschreiben mit einer logischen 1 gelöscht werden, muss eine absolute Zuweisung benutzt werden. Ein ODER löscht in diesen Registern ALLE gesetzten Bits!
</p><p>Beispiel:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/io.h&gt;</span>
...
<span class="me1">TIFR2</span> <span class="sy0">=</span> <span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>OCF2A<span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Nur Bit OCF2A löschen</span></pre></div></div>
<p>In Quellcodes, die für ältere Version den des avr-gcc/der avr-libc entwickelt wurden, werden einzelne Bits mittels der Funktionen sbi und cbi gesetzt bzw. gelöscht. Beide Funktionen sind nicht mehr erforderlich.
</p><p>Siehe auch:
</p>
<ul>
<li> <a href="http://www.mikrocontroller.net/articles/Bitmanipulation" title="Bitmanipulation">Bitmanipulation</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://www.nongnu.org/avr-libc/user-manual/index.html">Dokumentation der avr-libc</a> Abschnitt Modules/Special Function Registers
</li>
</ul>
<h2><span class="mw-headline" id="Lesen_aus_Registern">Lesen aus Registern</span></h2>
<p>Zum Lesen kann man auf Register einfach wie auf eine Variable zugreifen. In Quellcodes, die für ältere Versionen des avr-gcc/der avr-libc entwickelt wurden, erfolgt der Lesezugriff über die Funktion inp(). Aktuelle Versionen des Compilers unterstützen den Zugriff nun direkt und inp() ist nicht mehr erforderlich.
</p><p>Beispiel:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/io.h&gt;</span>
<span class="co2">#include &lt;stdint.h&gt;</span>
&nbsp;
<span class="kw4">uint8_t</span> foo<span class="sy0">;</span>
&nbsp;
<span class="co1">//...</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="coMULTI">/* kopiert den Status der Eingabepins an PortB 
       in die Variable foo: */</span>
    foo <span class="sy0">=</span> PINB<span class="sy0">;</span>    
    <span class="co1">//...</span>
<span class="br0">}</span></pre></div></div>
<p>Die Abfrage der Zustände von Bits erfolgt durch Einlesen des gesamten Registerinhalts und ausblenden der Bits deren Zustand nicht von Interesse ist. Einige Beispiele zum Prüfen ob Bits gesetzt oder gelöscht sind:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#define MEINBIT0 0 </span>
<span class="co2">#define MEINBIT2 2</span>
&nbsp;
<span class="kw4">uint8_t</span> i<span class="sy0">;</span>
&nbsp;
<span class="kw2">extern</span> test1<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
<span class="co1">// Funkion test1 aufrufen, wenn Bit 0 in Register PINA gesetzt (1) ist</span>
i <span class="sy0">=</span> PINA<span class="sy0">;</span>         <span class="co1">// Inhalt in Arbeitsvariable</span>
i <span class="sy0">=</span> i <span class="sy0">&amp;</span> <span class="nu12">0x01</span><span class="sy0">;</span>     <span class="co1">// alle Bits bis auf Bit 0 ausblenden (bitweise und)</span>
                  <span class="co1">// falls das Bit gesetzt war, hat i den Inhalt 1</span>
<span class="kw1">if</span> <span class="br0">(</span> i <span class="sy0">!=</span> <span class="nu0">0</span> <span class="br0">)</span> <span class="br0">{</span>   <span class="co1">// Ergebnis ungleich 0 (wahr)? </span>
  test1<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>         <span class="co1">// dann muss Bit 0 in i gesetzt sein -&gt; Funktion aufrufen</span>
<span class="br0">}</span>
<span class="co1">// verkürzt:</span>
<span class="kw1">if</span> <span class="br0">(</span> <span class="br0">(</span> PINA <span class="sy0">&amp;</span> <span class="nu12">0x01</span> <span class="br0">)</span> <span class="sy0">!=</span> <span class="nu0">0</span> <span class="br0">)</span> <span class="br0">{</span>
  test1<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="co1">// nochmals verkürzt:</span>
<span class="kw1">if</span> <span class="br0">(</span> PINA <span class="sy0">&amp;</span> <span class="nu12">0x01</span> <span class="br0">)</span> <span class="br0">{</span>
  test1<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="co1">// mit definierter Bitnummer:</span>
<span class="kw1">if</span> <span class="br0">(</span> PINA <span class="sy0">&amp;</span> <span class="br0">(</span> <span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> MEINBIT0 <span class="br0">)</span> <span class="br0">)</span> <span class="br0">{</span>
  test1<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
&nbsp;
<span class="co1">// Funktion aufrufen, wenn Bit 0 und/oder Bit 2 gesetzt ist. (Bit 0 und 2 also Wert 5) </span>
<span class="co1">// (Bedenke: Bit 0 hat Wert 1, Bit 1 hat Wert 2 und Bit 2 hat Wert 4)</span>
<span class="kw1">if</span> <span class="br0">(</span> PINA <span class="sy0">&amp;</span> <span class="nu12">0x05</span> <span class="br0">)</span> <span class="br0">{</span>
  test1<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>  <span class="co1">// Vergleich &lt;&gt; 0 (wahr), also mindestens eines der Bits gesetzt</span>
<span class="br0">}</span>
<span class="co1">// mit definierten Bitnummern:</span>
<span class="kw1">if</span> <span class="br0">(</span> PINA <span class="sy0">&amp;</span> <span class="br0">(</span> <span class="br0">(</span> <span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> MEINBIT0 <span class="br0">)</span> <span class="sy0">|</span> <span class="br0">(</span> <span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> MEINBIT2 <span class="br0">)</span> <span class="br0">)</span> <span class="br0">)</span> <span class="br0">{</span>
  test1<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
&nbsp;
<span class="co1">// Funktion aufrufen, wenn Bit 0 und Bit 2 gesetzt sind</span>
<span class="kw1">if</span> <span class="br0">(</span> <span class="br0">(</span> PINA <span class="sy0">&amp;</span> <span class="nu12">0x05</span> <span class="br0">)</span> <span class="sy0">==</span> <span class="nu12">0x05</span> <span class="br0">)</span> <span class="br0">{</span>  <span class="co1">// nur wahr, wenn beide Bits gesetzt</span>
  test1<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
&nbsp;
<span class="co1">// Funktion test2() aufrufen, wenn Bit 0 gelöscht (0) ist</span>
i <span class="sy0">=</span> PINA<span class="sy0">;</span>        <span class="co1">// einlesen in temporäre Variable</span>
i <span class="sy0">=</span> i <span class="sy0">&amp;</span> <span class="nu12">0x01</span><span class="sy0">;</span>    <span class="co1">// maskieren von Bit 0</span>
<span class="kw1">if</span> <span class="br0">(</span> i <span class="sy0">==</span> <span class="nu0">0</span> <span class="br0">)</span> <span class="br0">{</span>  <span class="co1">// Vergleich ist wahr, wenn Bit 0 nicht gesetzt ist</span>
  test2<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="co1">// analog mit not-Operator</span>
<span class="kw1">if</span> <span class="br0">(</span> <span class="sy0">!</span>i <span class="br0">)</span> <span class="br0">{</span>
  test2<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="co1">// nochmals verkürzt:</span>
<span class="kw1">if</span> <span class="br0">(</span> <span class="sy0">!</span><span class="br0">(</span> PINA <span class="sy0">&amp;</span> <span class="nu12">0x01</span> <span class="br0">)</span> <span class="br0">)</span> <span class="br0">{</span>
  test2<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<h2><span class="mw-headline" id="Warten_auf_einen_bestimmten_Zustand">Warten auf einen bestimmten Zustand</span></h2>
<p>Es gibt in der Bibliothek avr-libc Funktionen, die warten, bis ein bestimmter Zustand eines Bits erreicht ist. Es ist allerdings normalerweise eine eher unschöne Programmiertechnik, da in diesen Funktionen "blockierend" gewartet wird. Der Programmablauf bleibt also an dieser Stelle stehen, bis das maskierte Ereignis erfolgt ist. Setzt man den <a href="http://www.mikrocontroller.net/articles/Watchdog" title="Watchdog">Watchdog</a> ein, muss man darauf achten, dass dieser auch noch getriggert wird (Zurücksetzen des Watchdogtimers). 
</p><p>Die Funktion <b>loop_until_bit_is_set</b> wartet in einer Schleife, bis das definierte Bit gesetzt ist. Wenn das Bit beim Aufruf der Funktion bereits gesetzt ist, wird die Funktion sofort wieder verlassen. Das niederwertigste Bit hat die Bitnummer 0. 
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/io.h&gt;</span>
...
&nbsp;
<span class="coMULTI">/* Warten bis Bit Nr. 2 (das dritte Bit) in Register PINA gesetzt (1) ist */</span>
&nbsp;
<span class="co2">#define WARTEPIN PINA</span>
<span class="co2">#define WARTEBIT PA2</span>
&nbsp;
<span class="co1">// mit der avr-libc Funktion:</span>
loop_until_bit_is_set<span class="br0">(</span>WARTEPIN<span class="sy0">,</span> WARTEBIT<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
<span class="co1">// dito in "C-Standard":</span>
<span class="co1">// Durchlaufe die (leere) Schleife solange das WARTEBIT in Register WARTEPIN</span>
<span class="co1">// _nicht_ ungleich 0 (also 0) ist.</span>
<span class="kw1">while</span> <span class="br0">(</span> <span class="sy0">!</span><span class="br0">(</span>WARTEPIN <span class="sy0">&amp;</span> <span class="br0">(</span><span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> WARTEBIT<span class="br0">)</span><span class="br0">)</span> <span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
...</pre></div></div>
<p><br>
Die Funktion <b>loop_until_bit_is_clear</b> wartet in einer Schleife, bis das definierte Bit gelöscht ist. Wenn das Bit beim Aufruf der Funktion bereits gelöscht ist, wird die Funktion sofort wieder verlassen.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/io.h&gt;</span>
...
&nbsp;
<span class="coMULTI">/* Warten bis Bit Nr. 4 (das fuenfte Bit) in Register PINB geloescht (0) ist */</span>
<span class="co2">#define WARTEPIN PINB</span>
<span class="co2">#define WARTEBIT PB4</span>
&nbsp;
<span class="co1">// avr-libc-Funktion:</span>
loop_until_bit_is_clear<span class="br0">(</span>WARTEPIN<span class="sy0">,</span> WARTEBIT<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
<span class="co1">// dito in "C-Standard":</span>
<span class="co1">// Durchlaufe die (leere) Schleife solange das WARTEBIT in Register WARTEPIN</span>
<span class="co1">// gesetzt (1) ist </span>
<span class="kw1">while</span> <span class="br0">(</span> WARTEPIN <span class="sy0">&amp;</span> <span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>WARTEBIT<span class="br0">)</span> <span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
...</pre></div></div>
<p>Universeller und auch auf andere Plattformen besser übertragbar ist die Verwendung von C-Standardoperationen.
</p><p>Siehe auch: 
</p>
<ul>
<li> <a rel="nofollow" class="external text" href="http://www.nongnu.org/avr-libc/user-manual/index.html">Dokumentation der avr-libc</a> Abschnitt Modules/Special Function Registers
</li>
<li> <a href="http://www.mikrocontroller.net/articles/Bitmanipulation" title="Bitmanipulation">Bitmanipulation</a>
</li>
</ul>
<h2><span class="mw-headline" id="16-Bit_Register_.28ADC.2C_ICR1.2C_OCR1x.2C_TCNT1.2C_UBRR.29">16-Bit Register (ADC, ICR1, OCR1x, TCNT1, UBRR)</span></h2>
<p>Einige der Portregister in den AVR-Controllern sind 16 Bit breit. Im Datenblatt sind diese Register üblicherweise mit dem Suffix "L" (Low-Byte) und "H" (High-Byte) versehen. Die avr-libc definiert zusätzlich die meisten dieser Variablen die Bezeichnung ohne "L" oder "H". Auf diese Register kann dann direkt zugegriffen werden. Dies ist zum Beispiel der Fall für Register wie ADC oder TCNT1.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/io.h&gt;</span>
...
    <span class="kw4">uint16_t</span> foo<span class="sy0">;</span>
&nbsp;
    <span class="coMULTI">/* setzt die Wort-Variable foo auf den Wert der letzten AD-Wandlung */</span>
    foo <span class="sy0">=</span> ADC<span class="sy0">;</span></pre></div></div>
<p>Bei anderen Registern, wie zum Beispiel Baudraten-Register, liegen High- und Low-Teil nicht direkt nebeneinander im SFR-Bereich, so dass ein 16-Bit Zugriff nicht möglich ist und der Zugriff zusammengebastelt werden muss:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/io.h&gt;</span>
&nbsp;
<span class="co2">#ifndef F_CPU</span>
<span class="co2">#define F_CPU 3686400</span>
<span class="co2">#endif</span>
<span class="co2">#define UART_BAUD_RATE 9600</span>
&nbsp;
...
   <span class="kw4">uint16_t</span> baud <span class="sy0">=</span> F_CPU <span class="sy0">/</span> <span class="br0">(</span>UART_BAUD_RATE <span class="sy0">*</span> <span class="nu0">16L</span><span class="br0">)</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
&nbsp;
   UBRRH <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">uint8_t</span><span class="br0">)</span> <span class="br0">(</span>baud <span class="sy0">&gt;&gt;</span> <span class="nu0">8</span><span class="br0">)</span><span class="sy0">;</span>
   UBRRL <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">uint8_t</span><span class="br0">)</span> baud<span class="sy0">;</span>
...</pre></div></div>
<p>Bei einigen AVR-Typen wie ATmega8 oder ATmega16 teilen sich UBRRH und UCSRC die gleiche Speicher-Adresse. Damit der AVR trotzdem zwischen den beiden Registern unterscheiden kann, bestimmt das Bit7 (URSEL), welches Register tatsächlich beschrieben werden soll. <i>1000 0011</i> (0x83) adressiert demnach UCSRC und übergibt den Wert <i>3</i>. Und <i>0000 0011</i> (0x3) adressiert UBRRH und übergibt ebenfalls den Wert <i>3</i>. 
</p><p>Speziell bei den 16-Bit-Timern und auch beim ADC ist es bei allen Zugriffen auf Datenregister erforderlich, dass diese Daten synchronisiert sind. Wenn z.&nbsp;B. bei einem 16-Bit-Timer das High-Byte des Zählregisters gelesen wurde und vor dem Lesezugriff auf das Low-Byte ein Überlauf des Low-Bytes stattfindet, erhält man einen völlig unsinnigen Wert. Auch die Compare-Register müssen synchron geschrieben werden, da es ansonsten zu unerwünschten Compare-Ereignissen kommen kann. 
</p><p>Beim ADC besteht das Problem darin, dass zwischen den Zugriffen auf die beiden Teilregister eine Wandlung beendet werden kann und der ADC ein neues Ergebnis in ADCL und ADCH schreiben will, wodurch High- und Low-Byte nicht zusammenpassen.
</p><p>Um diese Datenmüllproduktion zu verhindern, gibt es in beiden Fällen eine Synchronisation, die jeweils durch den Zugriff auf das Low-Byte ausgelöst wird:
</p>
<ul>
<li> Bei den Timer-Registern (das gilt für alle TCNT-, OCR- und ICR-Register bei den 16-Bit-Timern) wird bei einem <i>Lesezugriff</i> auf das Low-Byte automatisch das High-Byte in ein temporäres Register, das ansonsten nach außen nicht sichtbar ist, geschoben. Greift man nun <i>anschließend</i> auf das High-Byte zu, dann wird eben dieses temporäre Register gelesen.
</li>
<li> Bei einem <i>Schreibzugriff</i> auf eines der genannten Register wird das High-Byte in besagtem temporären Register zwischengespeichert und erst beim Schreiben des Low-Bytes werden <i>beide</i> gleichzeitig in das eigentliche Register übernommen.
</li>
</ul>
<p>Das bedeutet für die Reihenfolge:
</p>
<ul>
<li> Lesezugriff: Erst Low-Byte, dann High-Byte
</li>
<li> Schreibzugriff: Erst High-Byte, dann Low-Byte
</li>
</ul>
<p>Des weiteren ist zu beachten, dass es für all diese 16-Bit-Register nur ein einziges temporäres Register gibt, so dass das Auftreten eines Interrupts, in dessen Handler ein solches Register manipuliert wird, bei einem durch ihn unterbrochenen Zugriff i.d.R. zu Datenmüll führt. 16-Bit-Zugriffe sind generell nicht atomar! Wenn mit Interrupts gearbeitet wird, kann es erforderlich sein, vor einem solchen Zugriff auf ein 16-Bit-Register die Interrupt-Bearbeitung zu deaktivieren.
</p><p>Beim ADC-Datenregister ADCH/ADCL ist die Synchronisierung anders gelöst. Hier wird beim Lesezugriff (ADCH/ADCL sind logischerweise read-only) auf das Low-Byte ADCL beide Teilregister für Zugriffe seitens des ADC so lange gesperrt, bis das High-Byte ADCH ausgelesen wurde. Dadurch kann der ADC nach einem Zugriff auf ADCL keinen neuen Wert in ADCH/ADCL ablegen, bis ADCH gelesen wurde. Ergebnisse von Wandlungen, die zwischen einem Zugriff auf ADCL und ADCH beendet werden, gehen verloren!
</p><p>Nach einem Zugriff auf ADCL muss grundsätzlich ADCH gelesen werden!
</p><p>In beiden Fällen – also sowohl bei den Timern als auch beim ADC – werden vom C-Compiler 16-Bit Pseudo-Register zur Verfügung gestellt (z.&nbsp;B. TCNT1H/TCNT1L → TCNT1, ADCH/ADCL → ADC bzw. ADCW), bei deren Verwendung der Compiler automatisch die richtige Zugriffsreihenfolge regelt. In C-Programmen sollten grundsätzlich diese 16-Bit-Register verwendet werden! Sollte trotzdem ein Zugriff auf ein Teilregister erforderlich sein, sind obige Angaben zu berücksichtigen.
</p><p>Es ist darauf zu achten, dass auch ein Zugriff auf die 16-Bit-Register vom Compiler in zwei 8-Bit-Zugriffe aufgeteilt wird und dementsprechend genauso nicht-atomar ist wie die Einzelzugriffe. Auch hier gilt, dass u.U. die Interrupt-Bearbeitung gesperrt werden muss, um Datenmüll zu vermeiden.
</p><p>Beim ADC gibt es für den Fall, dass eine Auflösung von 8 Bit ausreicht, die Möglichkeit, das Ergebnis "linksbündig" in ADCH/ADCL auszurichten, so dass die relevanten 8 MSB in ADCH stehen. In diesem Fall muss bzw. sollte nur ADCH ausgelesen werden.
</p><p>ADC und ADCW sind unterschiedliche Bezeichner für das selbe Registerpaar. Üblicherweise kann man in C-Programmen ADC verwenden, was analog zu den anderen 16-Bit-Registern benannt ist. ADCW (ADC Word) existiert nur deshalb, weil die Headerdateien auch für Assembler vorgesehen sind und es bereits einen Assembler-Befehl namens <i>adc</i> gibt. 
</p><p>Im Umgang mit 16-Bit Registern siehe auch:
</p>
<ul>
<li> <a rel="nofollow" class="external text" href="http://www.nongnu.org/avr-libc/user-manual/index.html">Dokumentation der avr-libc</a> Abschnitt Related Pages/Frequently Asked Questions/Nr. 8
</li>
<li> Datenblatt Abschnitt <i>Accessing 16-bit Registers</i>
</li>
</ul>
<h2><span class="mw-headline" id="IO-Register_als_Parameter_und_Variablen">IO-Register als Parameter und Variablen</span></h2>
<p>Um Register als Parameter für eigene Funktionen übergeben zu können, muss man sie als einen volatile uint8_t Pointer übergeben. Zum Beispiel:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/io.h&gt;</span>
<span class="co2">#include &lt;util/delay.h&gt;</span>
&nbsp;
<span class="kw4">uint8_t</span> key_pressed <span class="br0">(</span><span class="kw4">volatile</span> <span class="kw4">uint8_t</span> <span class="sy0">*</span>inputreg<span class="sy0">,</span> <span class="kw4">uint8_t</span> inputbit<span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw4">static</span> <span class="kw4">uint8_t</span> last_state <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
&nbsp;
  <span class="kw1">if</span> <span class="br0">(</span>last_state <span class="sy0">==</span> <span class="br0">(</span><span class="sy0">*</span>inputreg <span class="sy0">&amp;</span> <span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>inputbit<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> <span class="coMULTI">/* keine Änderung */</span>
&nbsp;
  <span class="coMULTI">/* Wenn doch, warten bis etwaiges Prellen vorbei ist: */</span>
  _delay_ms<span class="br0">(</span><span class="nu0">20</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
  <span class="coMULTI">/* Zustand für nächsten Aufruf merken: */</span>
  last_state <span class="sy0">=</span> <span class="sy0">*</span>inputreg <span class="sy0">&amp;</span> <span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>inputbit<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
  <span class="coMULTI">/* und den entprellten Tastendruck zurückgeben: */</span>
  <span class="kw1">return</span> <span class="sy0">*</span>inputreg <span class="sy0">&amp;</span> <span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>inputbit<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
&nbsp;
<span class="coMULTI">/* Beispiel für einen Funktionsaufruf: */</span>
&nbsp;
<span class="kw4">void</span> foo <span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span>
<span class="br0">{</span>
   <span class="kw4">uint8_t</span> i <span class="sy0">=</span> key_pressed <span class="br0">(</span><span class="sy0">&amp;</span>PINB<span class="sy0">,</span> PB1<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<p>Ein Aufruf der Funktion mit call by value würde Folgendes bewirken: Beim Funktionseintritt wird nur eine Kopie des momentanen Portzustandes angefertigt, die sich unabhängig vom tatsächlichen Zustand das Ports nicht mehr ändert, womit die Funktion wirkungslos wäre. Die Übergabe eines Zeigers wäre die Lösung, wenn der Compiler nicht optimieren würde. Denn dadurch wird im Programm nicht von der Hardware gelesen, sondern wieder nur von einem Abbild im Speicher. Das Ergebnis wäre das gleiche wie oben. Mit dem Schlüsselwort volatile sagt man nun dem Compiler, dass die entsprechende Variable entweder durch andere Softwareroutinen (Interrupts) oder durch die Hardware verändert werden kann.
</p><p>Siehe auch: <a rel="nofollow" class="external text" href="http://www.nongnu.org/avr-libc/user-manual/FAQ.html#faq_port_pass">avr-libc FAQ: "How do I pass an IO port as a parameter to a function?"</a>
</p>
<h1><span class="mw-headline" id="Zugriff_auf_IO-Ports">Zugriff auf IO-Ports</span></h1>
<p>Jeder AVR implementiert eine unterschiedliche Menge an GPIO-Registern
(GPIO - General Purpose Input/Output). Diese Register dienen dazu:
</p>
<ul>
<li> einzustellen welche der Anschlüsse ("Beinchen") des Controllers als Ein- oder Ausgänge dienen
</li>
<li> bei Ausgängen deren Zustand festzulegen
</li>
<li> bei Eingängen deren Zustand zu erfassen
</li>
</ul>
<p>Mittels GPIO werden digitale Zustände gesetzt und erfasst, d.h. die Spannung an einem Ausgang wird ein- oder ausgeschaltet und an einem Eingang wird erfasst, ob die anliegende Spannung über oder unter einem bestimmten Schwellwert liegt. Im Datenblatt Abschnitt Electrical Characteristics/DC Characteristics finden sich die Spannungswerte (V_OL, V_OH für Ausgänge, V_IL, V_IH für Eingänge).
</p><p>Die Verarbeitung von analogen Eingangswerten und die Ausgabe von Analogwerten wird in Kapitel <a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Analoge_Ein-_und_Ausgabe" title="AVR-GCC-Tutorial">Analoge Ein- und Ausgabe</a> behandelt.
</p><p>Die physischen Ein- und Ausgänge werden bei AVR-Controllern zu logischen Ports gruppiert.
</p><p>Alle Ports werden über Register gesteuert. Dazu sind jedem Port 3 Register zugeordnet:
</p>
<table class="wikitable">

<tbody><tr>
<th> DDRx
</th>
<td> Datenrichtungsregister für Port<b>x</b>.
<p><b>x</b> entspricht <b>A</b>, <b>B</b>, <b> C</b>, <b>D</b> usw. (abhängig von der Anzahl der Ports des verwendeten AVR). Bit im Register gesetzt (1) für Ausgang, Bit gelöscht (0) für Eingang.
</p>
</td></tr>
<tr>
<th> PINx
</th>
<td> Eingangsadresse für Port<b>x</b>.
<p>Zustand des Ports. Die Bits in PINx entsprechen dem Zustand der als Eingang definierten Portpins. Bit 1 wenn Pin "high", Bit 0 wenn Portpin low.
</p>
</td></tr>
<tr>
<th> PORTx
</th>
<td> Datenregister für Port<b>x</b>.
<p>Dieses Register wird verwendet, um die Ausgänge eines Ports anzusteuern. Bei Pins, die mittels DDRx auf Eingang geschaltet wurden, können über PORTx
die internen Pull-Up Widerstände aktiviert oder deaktiviert werden (1 = aktiv).
</p>
</td></tr></tbody></table>
<p>Die folgenden Beispiele gehen von einem AVR aus, der sowohl Port A als auch Port B besitzt. Sie müssen für andere AVRs (zum Beispiel ATmega8/48/88/168) entsprechend angepasst werden.
</p>
<h2><span class="mw-headline" id="Datenrichtung_bestimmen">Datenrichtung bestimmen</span></h2>
<p>Zuerst muss die Datenrichtung der verwendeten Pins bestimmt werden. Um dies zu erreichen, wird das Datenrichtungsregister des entsprechenden Ports beschrieben.
</p><p>Für jeden Pin, der als Ausgang verwendet werden soll, muss dabei das
entsprechende Bit auf dem Port gesetzt werden. Soll der Pin als Eingang
verwendet werden, muss das entsprechende Bit gelöscht sein.
</p><p>Beispiel:
Angenommen am Port B sollen die Pins 0 bis 4 als Ausgänge definiert werden, die noch verbleibenden Pins 5 bis 7 sollen als Eingänge fungieren. Dazu ist es daher notwendig, im für das Port B zuständigen Datenrichtungsregister DDRB folgende Bitkonfiguration einzutragen
</p>
<pre>  +---+---+---+---+---+---+---+---+
  | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 1 |
  +---+---+---+---+---+---+---+---+
  | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
</pre>
<p>In C liest sich das dann so:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co1">// in io.h wird u.a. DDRB definiert:</span>
<span class="co2">#include &lt;avr/io.h&gt;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
  <span class="co1">// Setzen der Bits 0,1,2,3 und 4</span>
  <span class="co1">// Binär 00011111 = Hexadezimal 1F</span>
  <span class="co1">// direkte Zuweisung - standardkonform */</span>
  DDRB <span class="sy0">=</span> <span class="nu12">0x1F</span><span class="sy0">;</span>    <span class="coMULTI">/* 
&nbsp;
  // übersichtliche Alternative - Binärschreibweise, aber kein ISO-C
  DDRB = 0b00011111;
&nbsp;
  // Ausführliche Schreibweise: identische Funktionalität, mehr Tipparbeit
  // aber übersichtlicher und selbsterklärend:
  DDRB |= (1 &lt;&lt; DDB0) | (1 &lt;&lt; DDB1) | (1 &lt;&lt; DDB2) | (1 &lt;&lt; DDB3) | (1 &lt;&lt; DDB4);</span></pre></div></div>
<p>Die Pins 5 bis 7 werden (da 0) als Eingänge geschaltet. Weitere Beispiele:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1">  <span class="co1">// Alle Pins des Ports B als Ausgang definieren:</span>
  DDRB <span class="sy0">=</span> <span class="nu12">0xff</span><span class="sy0">;</span> 
  <span class="co1">// Pin0 wieder auf Eingang und andere im ursprünglichen Zustand belassen:</span>
  DDRB <span class="sy0">&amp;=</span> ~<span class="br0">(</span><span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> DDB0<span class="br0">)</span><span class="sy0">;</span>
  <span class="co1">// Pin 3 und 4 auf Eingang und andere im ursprünglichen Zustand belassen:</span>
  DDRB <span class="sy0">&amp;=</span> ~<span class="br0">(</span><span class="br0">(</span><span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> DDB3<span class="br0">)</span> <span class="sy0">|</span> <span class="br0">(</span><span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> DDB4<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="co1">// Pin 0 und 3 wieder auf Ausgang und andere im ursprünglichen Zustand belassen:</span>
  DDRB <span class="sy0">|=</span> <span class="br0">(</span><span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> DDB0<span class="br0">)</span> <span class="sy0">|</span> <span class="br0">(</span><span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> DDB3<span class="br0">)</span><span class="sy0">;</span>
  <span class="co1">// Alle Pins auf Eingang:</span>
  DDRB <span class="sy0">=</span> <span class="nu12">0x00</span><span class="sy0">;</span></pre></div></div>
<h2><span class="mw-headline" id="Vordefinierte_Bitnummern_f.C3.BCr_I.2FO-Register">Vordefinierte Bitnummern für I/O-Register</span></h2>
<p>Die Bitnummern (z.&nbsp;B. PCx, PINCx und DDCx für den Port C) sind in den io*.h-Dateien der avr-libc definiert und dienen lediglich der besseren Lesbarkeit. Man muss diese Definitionen nicht verwenden oder kann auch einfach "immer" PAx, PBx, PCx usw. nutzen, auch wenn der Zugriff auf Bits in DDRx- oder PINx-Registern erfolgt. Für den Compiler sind die Ausdrücke (1&lt;&lt;PC7), (1&lt;&lt;DDC7) und (1&lt;&lt;PINC7) identisch zu (1&lt;&lt;7) (genauer: der Präprozessor ersetzt die Ausdrücke (1&lt;&lt;PC7),... zu (1&lt;&lt;7)). Ein Ausschnitt der Definitionen für Port C eines ATmega32 aus der iom32.h-Datei zur Verdeutlichung (analog für die weiteren Ports):
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1">...
<span class="coMULTI">/* PORTC */</span>
<span class="co2">#define PC7     7</span>
<span class="co2">#define PC6     6</span>
<span class="co2">#define PC5     5</span>
<span class="co2">#define PC4     4</span>
<span class="co2">#define PC3     3</span>
<span class="co2">#define PC2     2</span>
<span class="co2">#define PC1     1</span>
<span class="co2">#define PC0     0</span>
&nbsp;
<span class="coMULTI">/* DDRC */</span>
<span class="co2">#define DDC7    7</span>
<span class="co2">#define DDC6    6</span>
<span class="co2">#define DDC5    5</span>
<span class="co2">#define DDC4    4</span>
<span class="co2">#define DDC3    3</span>
<span class="co2">#define DDC2    2</span>
<span class="co2">#define DDC1    1</span>
<span class="co2">#define DDC0    0</span>
&nbsp;
<span class="coMULTI">/* PINC */</span>
<span class="co2">#define PINC7   7</span>
<span class="co2">#define PINC6   6</span>
<span class="co2">#define PINC5   5</span>
<span class="co2">#define PINC4   4</span>
<span class="co2">#define PINC3   3</span>
<span class="co2">#define PINC2   2</span>
<span class="co2">#define PINC1   1</span>
<span class="co2">#define PINC0   0</span></pre></div></div>
<p><br>
</p>
<h2><span class="mw-headline" id="Digitale_Signale">Digitale Signale</span></h2>
<p>Am einfachsten ist es, digitale Signale mit dem Mikrocontroller zu erfassen bzw. auszugeben.
</p>
<h2><span class="mw-headline" id="Ausg.C3.A4nge">Ausgänge</span></h2>
<p>Will man als Ausgang definierte Pins (entsprechende DDRx-Bits = 1) auf Logisch 1 setzen, setzt man die  entsprechenden Bits im Portregister.
</p><p>Mit dem Befehl
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/io.h&gt;</span>
...
    <span class="me1">PORTB</span> <span class="sy0">=</span> <span class="nu12">0x04</span><span class="sy0">;</span> <span class="coMULTI">/* besser PORTB=(1&lt;&lt;PB2) */</span>
&nbsp;
    <span class="co1">// übersichtliche Alternative - Binärschreibweise</span>
    PORTB <span class="sy0">=</span> <span class="nu6">0b00000100</span><span class="sy0">;</span>    <span class="coMULTI">/* direkte Zuweisung - übersichtlich */</span></pre></div></div>
<p>wird also der Ausgang an Pin PB2 gesetzt (Beachte, dass die Bits immer <i>von 0 an</i> gezählt werden, das niederwertigste Bit ist also Bitnummer 0 und nicht etwa Bitnummer 1).
</p><p>Man beachte, dass bei der Zuweisung mittels <b>=</b> immer alle Pins gleichzeitig angegeben werden. Man sollte also, wenn nur bestimmte Ausgänge geschaltet werden sollen, zuerst den aktuellen Wert des Ports einlesen und das Bit des gewünschten Ports in diesen Wert einfließen lassen. Will man also nur den dritten Pin (Bit Nr. 2) an Port B auf "high" setzen und den Status der anderen Ausgänge unverändert lassen, nutze man diese Form:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/io.h&gt;</span>
...
    <span class="me1">PORTB</span> <span class="sy0">=</span> PORTB <span class="sy0">|</span> <span class="nu12">0x04</span><span class="sy0">;</span> <span class="coMULTI">/* besser: PORTB = PORTB | ( 1&lt;&lt;PB2 ) */</span>
    <span class="coMULTI">/* vereinfacht durch Nutzung des |= Operators&nbsp;: */</span>
    PORTB <span class="sy0">|=</span> <span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>PB2<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="coMULTI">/* auch mehrere "gleichzeitig": */</span>
    PORTB <span class="sy0">|=</span> <span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>PB4<span class="br0">)</span> <span class="sy0">|</span> <span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>PB5<span class="br0">)</span><span class="sy0">;</span> <span class="coMULTI">/* Pins PB4 und PB5 "high" */</span></pre></div></div>
<p>"Ausschalten", also  Ausgänge auf "low" setzen, erfolgt analog:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/io.h&gt;</span>
...
    <span class="me1">PORTB</span> <span class="sy0">&amp;=</span> ~<span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>PB2<span class="br0">)</span><span class="sy0">;</span> <span class="coMULTI">/* löscht Bit 2 in PORTB und setzt damit Pin PB2 auf low */</span> 
    PORTB <span class="sy0">&amp;=</span> ~<span class="br0">(</span> <span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>PB4<span class="br0">)</span> <span class="sy0">|</span> <span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>PB5<span class="br0">)</span> <span class="br0">)</span><span class="sy0">;</span> <span class="coMULTI">/* Pin PB4 und Pin PB5 "low" */</span></pre></div></div>
<p>Siehe auch <a href="http://www.mikrocontroller.net/articles/Bitmanipulation" title="Bitmanipulation">Bitmanipulation</a>
</p><p>In Quellcodes, die für ältere Version den des avr-gcc/der avr-libc entwickelt wurden, werden einzelne Bits mittels der Funktionen sbi und cbi gesetzt bzw. gelöscht. Beide Funktionen sind in aktuellen Versionen der avr-libc nicht mehr enthalten und auch nicht mehr erforderlich.
</p><p><i>Falls der Anfangszustand von Ausgängen kritisch ist, muss die Reihenfolge beachtet werden, mit der die Datenrichtung (DDRx) eingestellt und der Ausgabewert (PORTx) gesetzt wird:</i>
</p><p>Für Ausgangspins, die mit Anfangswert "high" initialisiert werden sollen:
</p>
<ul>
<li> zuerst die Bits im PORTx-Register setzen
</li>
<li> anschließend die Datenrichtung auf Ausgang stellen
</li>
</ul>
<p>Daraus ergibt sich die Abfolge für einen Pin, der bisher als Eingang mit abgeschaltetem Pull-Up konfiguriert war:
</p>
<ul>
<li> setze PORTx: interner Pull-Up aktiv
</li>
<li> setze DDRx: Ausgang ("high")
</li>
</ul>
<p>Bei der Reihenfolge erst DDRx und dann PORTx kann es zu einem kurzen "low-Puls" kommen, der auch externe Pull-Up-Widerstände "überstimmt". Die (ungünstige) Abfolge: Eingang -&gt; setze DDRx: Ausgang (auf "low", da PORTx nach Reset 0) -&gt; setze PORTx: Ausgang auf high. Vergleiche dazu auch das Datenblatt Abschnitt <i>Configuring the Pin</i>.
</p>
<h2><span class="mw-headline" id="Eing.C3.A4nge_.28Wie_kommen_Signale_in_den_.C2.B5C.29">Eingänge (Wie kommen Signale in den µC)</span></h2>
<p>Die digitalen Eingangssignale können auf verschiedene Arten zu unserer Logik gelangen.
</p>
<h3><span class="mw-headline" id="Signalkopplung">Signalkopplung</span></h3>
<p>Am einfachsten ist es, wenn die Signale direkt aus einer anderen digitalen Schaltung übernommen werden können. Hat der Ausgang der entsprechenden Schaltung TTL-Pegel dann können wir sogar direkt den Ausgang der Schaltung mit einem Eingangspin von unserem Controller verbinden.
</p><p>Hat der Ausgang der anderen Schaltung keinen TTL-Pegel so müssen wir den Pegel über entsprechende Hardware (z.&nbsp;B. Optokoppler, <a href="http://www.mikrocontroller.net/articles/Widerstand#Spannungsteiler" title="Widerstand">Spannungsteiler</a>, "Levelshifter" aka <a href="http://www.mikrocontroller.net/articles/Pegelwandler" title="Pegelwandler">Pegelwandler</a>) anpassen.
</p><p>Die Masse der beiden Schaltungen muss selbstverständlich miteinander verbunden werden. Der Software selber ist es natürlich letztendlich egal, wie das Signal eingespeist wird. Wir können ja ohnehin lediglich prüfen, ob an einem Pin unseres Controllers eine logische 1 (Spannung größer ca. 0,7*Vcc) oder eine logische 0 (Spannung kleiner ca. 0,2*Vcc) anliegt. Detaillierte Informationen darüber, ab welcher Spannung ein Eingang als 0 ("low") bzw. 1 ("high") erkannt wird, liefert die Tabelle DC Characteristics im Datenblatt des genutzten Controllers.
</p>
<table class="wikitable" style="text-align:center">
<caption> <b>Spannungstabelle</b> <br> <small>(ca. Grenzwerte)</small>
</caption>
<tbody><tr>
<td>
</td>
<th> Low </th>
<th> High
</th></tr>
<tr>
<th> bei 5 V
</th>
<td> 1 V </td>
<td> 3,5 V
</td></tr>
<tr>
<th> bei 3,3 V
</th>
<td> 0,66 V </td>
<td> 2,31 V
</td></tr>
<tr>
<th> bei 1,8 V
</th>
<td> 0,36 V </td>
<td> 1,26 V
</td></tr></tbody></table>
<p><br>
Die Abfrage der Zustände der Portpins erfolgt direkt über den Registernamen.
</p>
<div style="margin:1em; padding:1em; border:solid 2px #ee0040;">
<p>Dabei ist wichtig, zur Abfrage der Eingänge <i>nicht</i> etwa Portregister <b>PORTx</b> zu verwenden, sondern Eingangsregister <b>PINx</b>. Ansonsten liest man nicht den Zustand der Eingänge, sondern den Status der internen Pull-Up-Widerstände. Die Abfrage der Pinzustände über PORTx statt PINx ist ein häufiger Fehler beim AVR-"Erstkontakt".
</p>
</div>
<p>Will man also die aktuellen Signalzustände von Port D abfragen und in eine Variable namens bPortD abspeichern, schreibt man folgende Befehlszeilen:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/io.h&gt;</span>
<span class="co2">#include &lt;stdint.h&gt;</span>
...
<span class="kw4">uint8_t</span> bPortD<span class="sy0">;</span>
...
<span class="me1">bPortD</span> <span class="sy0">=</span> PIND<span class="sy0">;</span>
...</pre></div></div>
<p>Mit den C-Bitoperationen kann man den Status der Bits abfragen.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/io.h&gt;</span>
...
<span class="coMULTI">/* Fuehre Aktion aus, wenn Bit Nr. 1 (das "zweite" Bit) in PINC gesetzt (1) ist */</span>
<span class="kw1">if</span> <span class="br0">(</span> PINC <span class="sy0">&amp;</span> <span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>PINC1<span class="br0">)</span> <span class="br0">)</span> <span class="br0">{</span>
  <span class="coMULTI">/* Aktion */</span>
<span class="br0">}</span>
&nbsp;
<span class="coMULTI">/* Fuehre Aktion aus, wenn Bit Nr. 2 (das "dritte" Bit) in PINB geloescht (0) ist */</span>
<span class="kw1">if</span> <span class="br0">(</span> <span class="sy0">!</span><span class="br0">(</span>PINB <span class="sy0">&amp;</span> <span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>PINB2<span class="br0">)</span><span class="br0">)</span> <span class="br0">)</span> <span class="br0">{</span>
  <span class="coMULTI">/* Aktion */</span>
<span class="br0">}</span>
...</pre></div></div>
<p>Siehe auch <a href="http://www.mikrocontroller.net/articles/Bitmanipulation#Bits_pr.C3.BCfen" title="Bitmanipulation">Bitmanipulation#Bits_prüfen</a>
</p>
<h3><span class="mw-headline" id="Interne_Pull-Up_Widerst.C3.A4nde">Interne Pull-Up Widerstände</span></h3>
<p>Portpins für Ein- und Ausgänge (GPIO) eines AVR verfügen über zuschaltbare interne Pull-Up Widerstände (nominal mehrere 10kOhm, z.&nbsp;B. ATmega16 20-50kOhm). Diese können in vielen Fällen statt externer Widerstände genutzt werden.
</p><p>Die internen Pull-Up Widerstände von Vcc zu den einzelnen Portpins werden über das Register <b> PORTx</b> aktiviert bzw. deaktiviert, wenn ein Pin als <b> Eingang</b> geschaltet ist.
</p><p>Wird der Wert des entsprechenden Portpins auf 1 gesetzt, so ist der Pull-Up Widerstand aktiviert. Bei einem Wert von 0 ist der Pull-Up Widerstand nicht aktiv. Man sollte jeweils entweder den internen oder einen externen Pull-Up Widerstand verwenden, aber nicht beide zusammen.
</p><p>Im Beispiel werden alle Pins des Ports D als Eingänge geschaltet und alle Pull-Up Widerstände aktiviert. Weiterhin wird Pin PC7 als Eingang geschaltet und dessen interner Pull-Up Widerstand aktiviert, ohne die Einstellungen für die anderen Portpins (PC0-PC6) zu verändern.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/io.h&gt;</span>
...
<span class="me1">DDRD</span>  <span class="sy0">=</span> <span class="nu12">0x00</span><span class="sy0">;</span> <span class="coMULTI">/* alle Pins von Port D als Eingang */</span>
PORTD <span class="sy0">=</span> <span class="nu12">0xff</span><span class="sy0">;</span> <span class="coMULTI">/* interne Pull-Ups an allen Port-Pins aktivieren */</span>
...
<span class="me1">DDRC</span>  <span class="sy0">&amp;=</span> ~<span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>PC7<span class="br0">)</span><span class="sy0">;</span>  <span class="coMULTI">/* Pin PC7 als Eingang */</span>
PORTC <span class="sy0">|=</span> <span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>PC7<span class="br0">)</span><span class="sy0">;</span>    <span class="coMULTI">/* internen Pull-Up an PC7 aktivieren */</span></pre></div></div>
<h3><span class="mw-headline" id="Taster_und_Schalter">Taster und Schalter</span></h3>
<p>Der Anschluss mechanischer Kontakte an den Mikrocontroller, ist zwischen zwei unterschiedliche Methoden zu unterscheiden: <i>Active Low</i> und <i>Active High</i>.
</p>
<ul class="gallery mw-gallery-traditional">
	<li class="gallerycaption">Anschluss mechanischer Kontakte an einen µC</li>
		<li class="gallerybox" style="width: 335px"><div style="width: 335px">
			<div class="thumb" style="width: 330px;"><div style="margin:15px auto;"><a href="http://www.mikrocontroller.net/articles/Datei:Active_Low.gif" class="image"><img alt="" src="./AVR-GCC-Tutorial - Mikrocontroller.net_files/Active_Low.gif" width="300" height="300"></a></div></div>
			<div class="gallerytext">
<p><b>Active Low:</b> Bei dieser Methode wird der Kontakt zwischen den Eingangspin des Controllers und Masse geschaltet. Damit bei offenem Schalter der Controller kein undefiniertes Signal bekommt, wird zwischen die Versorgungsspannung und den Eingangspin ein sogenannter <b>Pull-Up</b> Widerstand geschaltet. Dieser dient dazu, den Pegel bei geöffnetem Schalter auf logisch 1 zu ziehen.
</p>
			</div>
		</div></li>
		<li class="gallerybox" style="width: 335px"><div style="width: 335px">
			<div class="thumb" style="width: 330px;"><div style="margin:15px auto;"><a href="http://www.mikrocontroller.net/articles/Datei:Active_High.gif" class="image"><img alt="" src="./AVR-GCC-Tutorial - Mikrocontroller.net_files/Active_High.gif" width="300" height="300"></a></div></div>
			<div class="gallerytext">
<p><b>Active High:</b> Hier wird der Kontakt zwischen die Versorgungsspannung und den Eingangspin geschaltet. Damit bei offener Schalterstellung kein undefiniertes Signal am Controller ansteht, wird zwischen den Eingangspin und die Masse ein <b>Pull-Down</b> Widerstand geschaltet. Dieser dient dazu, den Pegel bei geöffneter Schalterstellung auf logisch 0 zu halten.
</p>
			</div>
		</div></li>
</ul>
<p>Der Widerstandswert von Pull-Up- und Pull-Down-Widerständen ist an sich nicht kritisch. Wird er allerdings zu hoch gewählt, ist die Wirkung eventuell nicht gegeben. Als üblicher Wert haben sich 10 kOhm eingebürgert. Die AVRs verfügen an den meisten Pins über zuschaltbare interne Pull-Up Widerstände (vgl. Abschnitt <a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Interne_Pull-Up_Widerst.C3.A4nde" title="AVR-GCC-Tutorial">Interne Pull-Up Widerstände</a>), welche insbesondere wie hier bei Tastern und ähnlichen Bauteilen (z.&nbsp;B. Drehgebern) statt externer Bauteile verwendet werden können. Interne Pull-Down-Widerstand sind nicht verfügbar und müssen daher in Form zusätzlicher Bauteile in die Schaltung eingefügt werden.
</p>
<h4><span class="mw-headline" id="Taster_entprellen">Taster entprellen</span></h4>
<p>Siehe: <i><a href="http://www.mikrocontroller.net/articles/Entprellung#Warteschleifen-Verfahren" title="Entprellung">Entprellung: Warteschleifen-Verfahren</a></i>
</p>
<h1><span class="mw-headline" id="Warteschleifen_.28delay.h.29">Warteschleifen (delay.h)</span></h1>
<p>Der Programmablauf kann verschiedene Arten von Wartefunktionen erfordern:
</p>
<ul>
<li> Warten im Sinn von Zeitvertrödeln
</li>
<li> Warten auf einen bestimmten Zustand an den I/O-Pins
</li>
<li> Warten auf einen bestimmten Zeitpunkt (siehe Timer)
</li>
<li> Warten auf einen bestimmten Zählerstand (siehe Counter)
</li>
</ul>
<p>Der einfachste Fall, das Zeitvertrödeln, kann in vielen Fällen und mit großer Genauigkeit anhand der avr-libc Bibliotheksfunktionen _delay_ms() und _delay_us() erledigt werden. Die Bibliotheksfunktionen sind einfachen Zählschleifen (Warteschleifen) vorzuziehen, da leere Zählschleifen ohne besondere Vorkehrungen sonst bei eingeschalteter Optimierung vom avr-gcc-Compiler wegoptimiert werden. Weiterhin sind die Bibliotheksfunktionen bereits darauf vorbereitet, die in F_CPU definierte Taktfrequenz zu verwenden. Außerdem sind die Funktionen der Bibliothek wirklich getestet.
</p><p>Einfach!? Schon, aber während gewartet wird, macht der µC nichts anderes mehr (abgesehen von möglicherweise auftretenden Interrupts, falls welche aktiviert sind). Die Wartefunktion blockiert den Programmablauf. Möchte man einerseits warten, um z.&nbsp;B. eine LED blinken zu lassen und gleichzeitig andere Aktionen ausführen z.&nbsp;B. weitere LED bedienen, sollten die Timer/Counter des AVR verwendet werden.
</p><p>Die Bibliotheksfunktionen funktionieren allerdings nur dann korrekt, wenn sie mit zur Übersetzungszeit (beim Compilieren) bekannten konstanten Werten aufgerufen werden. Der Quellcode muss mit eingeschalteter Optimierung übersetzt werden, sonst wird sehr viel Maschinencode erzeugt, und die Wartezeiten stimmen nicht mehr mit dem Parameter überein.
</p><p>Eine weitere Einschränkung liegt darin, daß sie möglicherweise länger warten, als erwartet, nämlich in dem Fall, daß Interrupts auftreten und die _delay...()-Funktion unterbrechen. Genau genommen warten diese nämlich nicht eine bestimmte Zeit, sondern verbrauchen eine bestimmte Anzahl von Prozessortakten. Die wiederum ist so bemessen, daß ohne Unterbrechung durch Interrupts die gewünschte Wartezeit erreicht wird.
Wird das Warten aber durch eine oder mehrere ISR unterbrochen, die zusammen 1% Prozessorzeit verbrauchen, dann dauert das Warten etwa 1% länger. Bei 50% Last durch die ISR dauert das Warten doppelt solange wie gewünscht, bei 90% zehnmal solange...
</p><p>Abhängig von der Version der Bibliothek verhalten sich die Bibliotheksfunktionen etwas unterschiedlich.
</p>
<h2><span class="mw-headline" id="avr-libc_Versionen_bis_1.6">avr-libc Versionen bis 1.6</span></h2>
<p>Die Wartezeit der Funktion _delay_ms() ist auf 262,14ms/F_CPU (in MHz) begrenzt, d.h. bei 20 MHz kann man nur max. 13,1ms warten. Die Wartezeit der Funktion _delay_us() ist auf 768us/F_CPU (in MHz) begrenzt, d.h. bei 20 MHz kann man nur max. 38,4µs warten. Längere Wartezeiten müssen dann über einen mehrfachen Aufruf in einer Schleife gelöst werden.
</p><p>Beispiel: Blinken einer LED an PORTB Pin PB0 im ca. 1s Rhythmus
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/io.h&gt;</span>
<span class="co2">#ifndef F_CPU</span>
<span class="coMULTI">/* Definiere F_CPU, wenn F_CPU nicht bereits vorher definiert 
   (z.&amp;nbsp;B. durch Übergabe als Parameter zum Compiler innerhalb 
   des Makefiles). Zusätzlich Ausgabe einer Warnung, die auf die
   "nachträgliche" Definition hinweist */</span>
<span class="co2">#warning "F_CPU war noch nicht definiert, wird nun mit 3686400 definiert"</span>
<span class="co2">#define F_CPU 3686400UL     /* Quarz mit 3.6864 Mhz */</span>
<span class="co2">#endif</span>
<span class="co2">#include &lt;util/delay.h&gt;     /* in älteren avr-libc Versionen &lt;avr/delay.h&gt; */ </span>
&nbsp;
<span class="coMULTI">/*
 lange, variable Verzögerungszeit, Einheit in Millisekunden
&nbsp;
Die maximale Zeit pro Funktionsaufruf ist begrenzt auf 
262.14 ms / F_CPU in MHz (im Beispiel: 
262.1 / 3.6864 = max. 71 ms) 
&nbsp;
Daher wird die kleine Warteschleife mehrfach aufgerufen,
um auf eine längere Wartezeit zu kommen. Die zusätzliche 
Prüfung der Schleifenbedingung lässt die Wartezeit geringfügig
ungenau werden (macht hier vielleicht 2-3ms aus).
*/</span>
&nbsp;
<span class="kw4">void</span> long_delay<span class="br0">(</span><span class="kw4">uint16_t</span> ms<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="sy0">;</span> ms<span class="sy0">&gt;</span><span class="nu0">0</span><span class="sy0">;</span> ms<span class="sy0">--</span><span class="br0">)</span> _delay_ms<span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span> <span class="kw4">void</span> <span class="br0">)</span>
<span class="br0">{</span>
    DDRB <span class="sy0">=</span> <span class="br0">(</span> <span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> PB0 <span class="br0">)</span><span class="sy0">;</span>        <span class="co1">// PB0 an PORTB als Ausgang setzen</span>
&nbsp;
    <span class="kw1">while</span><span class="br0">(</span> <span class="nu0">1</span> <span class="br0">)</span>                  <span class="co1">// Endlosschleife</span>
    <span class="br0">{</span>                
        PORTB <span class="sy0">^=</span> <span class="br0">(</span> <span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> PB0 <span class="br0">)</span><span class="sy0">;</span>  <span class="co1">// Toggle PB0 z.&amp;nbsp;B. angeschlossene LED</span>
        long_delay<span class="br0">(</span><span class="nu0">1000</span><span class="br0">)</span><span class="sy0">;</span>       <span class="co1">// Eine Sekunde warten...</span>
    <span class="br0">}</span>
&nbsp;
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<h2><span class="mw-headline" id="avr-libc_Versionen_ab_1.7">avr-libc Versionen ab 1.7</span></h2>
<p>_delay_ms() kann mit einem Argument bis 6553,5 ms (= 6,5535 Sekunden) benutzt werden. Es ist nicht möglich, eine Variable als Argument zu übergeben. Wird die früher gültige Grenze von 262,14 ms/F_CPU (in MHz) überschritten, so arbeitet _delay_ms() einfach etwas ungenauer und zählt nur noch mit einer Auflösung von 1/10 ms. Eine Verzögerung von 1000,10 ms ließe sich nicht mehr von einer von 1000,19 ms unterscheiden. Ein Verlust, der sich im Allgemeinen verschmerzen lässt. Dem Programmierer wird keine Rückmeldung gegeben, dass die Funktion ggf. gröber arbeitet, d.h. wenn es darauf ankommt, bitte den Parameter wie bisher geschickt wählen.
</p><p>Die Funktion _delay_us() wurde ebenfalls erweitert. Wenn deren maximal als genau behandelbares Argument überschritten wird, benutzt diese intern _delay_ms(). Damit gelten in diesem Fall die _delay_ms() Einschränkungen.
</p><p>Beispiel: Blinken einer LED an PORTB Pin PB0 im ca. 1s Rhythmus, avr-libc ab Version 1.6
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/io.h&gt;</span>
<span class="co2">#ifndef F_CPU</span>
<span class="coMULTI">/* Definiere F_CPU, wenn F_CPU nicht bereits vorher definiert 
   (z.B. durch Übergabe als Parameter zum Compiler innerhalb 
   des Makefiles). Zusätzlich Ausgabe einer Warnung, die auf die
   "nachträgliche" Definition hinweist */</span>
<span class="co2">#warning "F_CPU war noch nicht definiert, wird nun mit 3686400 definiert"</span>
<span class="co2">#define F_CPU 3686400UL     /* Quarz mit 3.6864 Mhz */</span>
<span class="co2">#endif</span>
<span class="co2">#include &lt;util/delay.h&gt;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span> <span class="kw4">void</span> <span class="br0">)</span>
<span class="br0">{</span>
    DDRB <span class="sy0">=</span> <span class="br0">(</span> <span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> PB0 <span class="br0">)</span><span class="sy0">;</span>        <span class="co1">// PB0 an PORTB als Ausgang setzen</span>
&nbsp;
    <span class="kw1">while</span><span class="br0">(</span> <span class="nu0">1</span> <span class="br0">)</span> <span class="br0">{</span>                <span class="co1">// Endlosschleife</span>
        PORTB <span class="sy0">^=</span> <span class="br0">(</span> <span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> PB0 <span class="br0">)</span><span class="sy0">;</span>  <span class="co1">// Toggle PB0 z.B. angeschlossene LED</span>
        _delay_ms<span class="br0">(</span><span class="nu0">1000</span><span class="br0">)</span><span class="sy0">;</span>        <span class="co1">// Eine Sekunde +/-1/10000 Sekunde warten...</span>
                                <span class="co1">// funktioniert nicht mit Bibliotheken vor 1.6</span>
&nbsp;
    <span class="br0">}</span>
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<p>Trick zur Übergabe einer Variablen an _delay_ms():
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/io.h&gt;</span>
<span class="co2">#ifndef F_CPU</span>
<span class="co2">#warning "F_CPU war noch nicht definiert, wird nun mit 3686400 definiert"</span>
<span class="co2">#define F_CPU 3686400UL     /* Quarz mit 3.6864 Mhz */</span>
<span class="co2">#endif</span>
<span class="co2">#include &lt;util/delay.h&gt;</span>
&nbsp;
<span class="kw4">void</span> sleep <span class="br0">(</span> <span class="kw4">uint8_t</span> ms <span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="sy0">;</span> ms <span class="sy0">&gt;</span> <span class="nu0">0</span><span class="sy0">;</span> ms<span class="sy0">--</span><span class="br0">)</span> _delay_ms<span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span> <span class="kw4">void</span> <span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> x <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>                  <span class="co1">// Variable als Wartezeit erstellen</span>
    DDRB <span class="sy0">=</span> <span class="br0">(</span> <span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> PB0 <span class="br0">)</span><span class="sy0">;</span>        <span class="co1">// PB0 an PORTB als Ausgang setzen</span>
&nbsp;
    <span class="kw1">while</span><span class="br0">(</span> <span class="nu0">1</span> <span class="br0">)</span> <span class="br0">{</span>                <span class="co1">// Endlosschleife</span>
        PORTB <span class="sy0">^=</span> <span class="br0">(</span> <span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> PB0 <span class="br0">)</span><span class="sy0">;</span>  <span class="co1">// Toggle PB0 z.B. angeschlossene LED</span>
        sleep<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span> 
        x<span class="sy0">++;</span>       
    <span class="br0">}</span>
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<p><br>
Die _delay_ms() und die _delay_us aus <b>avr-libc 1.7.0</b> sind fehlerhaft. _delay_ms () läuft 4x schneller als erwartet. Abhilfe ist eine korrigierte Includedatei: <a class="external autonumber" href="http://www.mikrocontroller.net/topic/196738#1943039">[1]</a>
</p>
<h1><span class="mw-headline" id="Programmieren_mit_Interrupts">Programmieren mit Interrupts</span></h1>
<div style="float:right; margin:2em;">
<p><a href="http://www.mikrocontroller.net/articles/Datei:Interrupt_Programme.gif" class="image"><img alt="Interrupt Programme.gif" src="./AVR-GCC-Tutorial - Mikrocontroller.net_files/Interrupt_Programme.gif" width="360" height="240"></a>
</p>
</div>
<p>Nachdem wir nun alles Wissenswerte für die serielle Programmerstellung
gelernt haben nehmen wir jetzt ein völlig anderes Thema in Angriff, nämlich
die Programmierung unter Zuhilfenahme der Interrupts des AVR.
</p><p>Tritt ein Interrupt auf, unterbricht (engl. interrupts) der Controller die Verarbeitung des Hauptprogramms und verzweigt zu einer Interruptroutine. Das Hauptprogramm wird also beim Eintreffen eines Interrupts unterbrochen, die Interruptroutine ausgeführt und danach erst wieder das Hauptprogramm an der Unterbrechungsstelle fortgesetzt (vgl. die Abbildung).
</p><p>Um Interrupts verarbeiten zu können, ist folgendes zu beachten:
</p>
<ul>
<li> Für jede aktivierte Interruptquelle ist eine Funktion zu programmieren, in der die beim Auftreten des jeweiligen Interrupts erforderlichen Verarbeitungsschritte enthalten sind. Für diese Funktion existieren verschiedene Bezeichnungen. Üblich sind die englischen Begriffe Interrupt-Handler oder Interrupt-Service-Routinen (ISR), man findet aber auch die Bezeichnungen Interruptverarbeitungs- oder -behandlungsroutine oder auch kurz Interruptroutine. Zum Beispiel wird üblicherweise in der ISR zur Verarbeitung des Empfangsinterrupts eines UARTs (UART-RX Interrupt) das empfangene Zeichen in einen Zwischenspeicher (FIFO-Buffer) kopiert, dessen Inhalt später von anderen Programmteilen geleert wird. Sofern der Zwischenspeicher ausreichend groß ist, geht also kein Zeichen verloren, auch wenn im Hauptprogramm zeitintensive Operationen durchgeführt werden.
</li>
<li> Die benötigten Interrupts sind in den jeweiligen Funktionsbausteinen einzuschalten. Dies erfolgt über das jeweilige Aktivierungsbit (Interrupt Enable) in einem der Hardwareregister (z.B. RX(Complete)Interrupt Enable eines UARTs)
</li>
<li> Sämtliche Interrupts werden über einen weiteren globalen Schalter aktiviert und deaktiviert. Zur Verarbeitung der Interrupts ist dieser Schalter zu aktivieren (sei(), siehe unten).
</li>
</ul>
<p>Alle Punkte sind zu beachten. Fehlt z.B. die globale Aktivierung, werden Interruptroutinen auch dann nicht aufgerufen, wenn sie im Funktionsbaustein eingeschaltet sind und eine Behandlungsroutine verhanden ist.
</p><p>Siehe auch
</p>
<ul>
<li> <a class="external text" href="http://www.mikrocontroller.net/forum/read-1-235092.html#new">Ausführlicher Thread im Forum</a>
</li>
<li> Artikel <a href="http://www.mikrocontroller.net/articles/Interrupt" title="Interrupt">Interrupt</a>
</li>
<li> Artikel <a href="http://www.mikrocontroller.net/articles/Multitasking" title="Multitasking">Multitasking</a>
</li>
</ul>
<p><br clear="all">
</p>
<h2><span class="mw-headline" id="Anforderungen_an_Interrupt-Routinen">Anforderungen an Interrupt-Routinen</span></h2>
<p>Um unliebsamen Überraschungen vorzubeugen, sollten einige Grundregeln bei der Implementierung der Interruptroutinen beachtet werden. Interruptroutinen sollten möglichst kurz und schnell abarbeitbar sein, daraus folgt:
</p>
<ul>
<li> Keine umfangreichen Berechnungen innerhalb der Interruptroutine. (*)
</li>
<li> Keine langen Programmschleifen.
</li>
<li> Obwohl es möglich ist, während der Abarbeitung einer Interruptroutine andere oder sogar den gleichen Interrupt wieder zuzulassen, wird davon ohne genaue Kenntnis der internen Abläufe dringend abgeraten.
</li>
</ul>
<p>Interruptroutinen (ISRs) sollten also möglichst kurz sein und keine Schleifen mit vielen Durchläufen enthalten. Längere Operationen können meist in einen "Interrupt-Teil" in einer ISR und einen "Arbeitsteil" im Hauptprogramm aufgetrennt werden. Z.B. Speichern des Zustands aller Eingänge im EEPROM in bestimmten Zeitabständen: ISR-Teil: Zeitvergleich (Timer,RTC) mit Logzeit/-intervall. Bei Übereinstimmung ein globales Flag setzen (volatile bei Flag-Deklaration nicht vergessen, s.u.). Dann im Hauptprogramm prüfen, ob das Flag gesetzt ist. Wenn ja: die Daten im EEPROM ablegen und Flag löschen.
</p><p>(*)
Hinweis: 
Es gibt allerdings die seltene Situation, dass man gerade eingelesene
ADC-Werte sofort verarbeiten muss. Besonders dann, wenn man mehrere Werte sehr
schnell hintereinander bekommt. Dann bleibt einem nichts anderes übrig, als die
Werte noch in der ISR zu verarbeiten. Kommt aber sehr selten vor und sollte
durch geeignete Wahl des Systemtaktes bzw. Auswahl des Controllers vermieden werden!
</p>
<h2><span class="mw-headline" id="Interrupt-Quellen">Interrupt-Quellen</span></h2>
<p>Die folgenden Ereignisse können einen Interrupt auf einem AVR AT90S2313 auslösen, wobei die Reihenfolge der Auflistung auch die Priorität der Interrupts aufzeigt.
</p>
<ul>
<li> Reset
</li>
<li> Externer Interrupt 0
</li>
<li> Externer Interrupt 1
</li>
<li> Timer/Counter 1 Capture Ereignis
</li>
<li> Timer/Counter 1 Compare Match
</li>
<li> Timer/Counter 1 Überlauf
</li>
<li> Timer/Counter 0 Überlauf
</li>
<li> UART Zeichen empfangen
</li>
<li> UART Datenregister leer
</li>
<li> UART Zeichen gesendet
</li>
<li> Analoger Komparator
</li>
</ul>
<p>Die Anzahl der möglichen Interruptquellen variiert zwischen den verschiedenen Microcontroller-Typen. Im Zweifel hilft ein Blick ins Datenblatt ("Interrupt Vectors").
</p>
<h2><span class="mw-headline" id="Register">Register</span></h2>
<p>Der AT90S2313 verfügt über 2 Register die mit den
Interrupts zusammenhängen.
</p>
<table class="wikitable">

<tbody><tr>
<td> <b>GIMSK</b>
</td>
<td> <b>G</b>eneral <b>I</b>nterrupt <b>M</b>a<b>sk</b> Register.<br>
<table class="wikitable" style="text-align:center">

<tbody><tr>
<th> Bit
</th>
<td> 7 </td>
<td> 6</td>
<td> 5 </td>
<td> 4 </td>
<td> 3 </td>
<td> 2 </td>
<td> 1 </td>
<td> 0
</td></tr>
<tr>
<th> Name
</th>
<td> <b>INT1</b> </td>
<td> <b>INT0</b> </td>
<td> <b>-</b> </td>
<td> <b>-</b> </td>
<td> <b>-</b> </td>
<td> <b>-</b> </td>
<td> <b>-</b> </td>
<td> <b>-</b>
</td></tr>
<tr>
<th> R/W
</th>
<td> R/W </td>
<td> R/W </td>
<td> R </td>
<td> R </td>
<td> R </td>
<td> R </td>
<td> R </td>
<td> R
</td></tr>
<tr>
<th> Initialwert
</th>
<td> 0 </td>
<td> 0 </td>
<td> 0 </td>
<td> 0 </td>
<td> 0 </td>
<td> 0 </td>
<td> 0 </td>
<td> 0
</td></tr></tbody></table>
<p><b>INT1</b> (External <b>Int</b>errupt Request <b>1</b> Enable)
</p>
<dl>
<dd>Wenn dieses Bit gesetzt ist, wird ein Interrupt ausgelöst, wenn am <b>INT1</b>-Pin eine steigende oder fallende (je nach Konfiguration im <b>MCUCR</b>) Flanke erkannt wird.
</dd>
<dd>Das Global Enable Interrupt Flag muss selbstverständlich auch gesetzt sein.
</dd>
<dd>Der Interrupt wird auch ausgelöst, wenn der Pin als Ausgang geschaltet ist. Auf diese Weise bietet sich die Möglichkeit, Software-Interrupts zu realisieren.
</dd>
</dl>
<p><b>INT0</b> (External <b>Int</b>errupt Request <b>0</b> Enable)
</p>
<dl>
<dd>Wenn dieses Bit gesetzt ist, wird ein Interrupt ausgelöst, wenn am <b>INT0</b>-Pin eine steigende oder fallende (je nach Konfiguration im <b>MCUCR</b>) Flanke erkannt wird.
</dd>
<dd>Das Global Enable Interrupt Flag muss selbstverständlich auch gesetzt sein.
</dd>
<dd>Der Interrupt wird auch ausgelöst, wenn der Pin als Ausgang geschaltet ist. Auf diese Weise bietet sich die Möglichkeit, Software-Interrupts zu realisieren.
</dd>
</dl>
</td></tr>
<tr>
<td> <b>GIFR</b>
</td>
<td> <b>G</b>eneral <b>I</b>nterrupt <b>F</b>lag <b>R</b>egister.
<table class="wikitable" style="text-align:center">

<tbody><tr>
<th> Bit
</th>
<td> 7 </td>
<td> 6 </td>
<td> 5 </td>
<td> 4 </td>
<td> 3 </td>
<td> 2 </td>
<td> 1 </td>
<td> 0
</td></tr>
<tr>
<th> Name
</th>
<td> <b>INTF1</b> </td>
<td> <b>INTF0</b> </td>
<td> <b>-</b> </td>
<td> <b>-</b> </td>
<td> <b>-</b> </td>
<td> <b>-</b> </td>
<td> <b>-</b> </td>
<td> <b>-</b>
</td></tr>
<tr>
<th> R/W
</th>
<td> R/W </td>
<td> R/W </td>
<td> R </td>
<td> R </td>
<td> R </td>
<td> R </td>
<td> R </td>
<td> R
</td></tr>
<tr>
<th> Initialwert
</th>
<td> 0 </td>
<td> 0 </td>
<td> 0 </td>
<td> 0 </td>
<td> 0 </td>
<td> 0 </td>
<td> 0 </td>
<td> 0
</td></tr></tbody></table>
<p><b>INTF1</b> (External <b>Int</b>errupt Flag <b>1</b>)
</p>
<dl>
<dd>Dieses Bit wird gesetzt, wenn am <b>INT1</b>-Pin eine Interrupt-Bedingung, entsprechend der Konfiguration, als eingetreten erkannt wird. Wenn das Global Enable Interrupt Flag gesetzt ist, wird die Interruptroutine angesprungen.
</dd>
<dd>Das Flag wird automatisch gelöscht, wenn die Interruptroutine beendet ist. Alternativ kann das Flag gelöscht werden, indem der Wert <b>1(!)</b> eingeschrieben wird.
</dd>
</dl>
<p><b>INTF0</b> (External <b>Int</b>errupt Flag <b>0</b>)
</p>
<dl>
<dd>Dieses Bit wird gesetzt, wenn am <b>INT0</b>-Pin eine Interrupt-Bedingung, entsprechend der Konfiguration, als eingetreten erkannt wird. Wenn das Global Enable Interrupt Flag gesetzt ist, wird die Interruptroutine angesprungen.
</dd>
<dd>Das Flag wird automatisch gelöscht, wenn die Interruptroutine beendet ist. Alternativ kann das Flag gelöscht werden, indem der Wert <b>1(!)</b> eingeschrieben wird.
</dd>
</dl>
</td></tr>
<tr>
<td> <b>MCUCR</b>
</td>
<td> <b>MCU</b> <b>C</b>ontrol <b>R</b>egister.
<p>Das MCU Control Register enthält Kontrollbits für allgemeine MCU-Funktionen.
</p>
<table class="wikitable" style="text-align:center">

<tbody><tr>
<th> Bit
</th>
<td> 7 </td>
<td> 6 </td>
<td> 5 </td>
<td> 4 </td>
<td> 3 </td>
<td> 2 </td>
<td> 1 </td>
<td> 0
</td></tr>
<tr>
<th> Name
</th>
<td> <b>-</b></td>
<td> <b>-</b></td>
<td> <b>SE</b></td>
<td> <b>SM</b></td>
<td> <b>ISC11</b></td>
<td> <b>ISC10</b></td>
<td> <b>ISC01</b></td>
<td> <b>ISC00</b>
</td></tr>
<tr>
<th> R/W
</th>
<td> R </td>
<td> R </td>
<td> R/W </td>
<td> R/W </td>
<td> R/W </td>
<td> R/W </td>
<td> R/W </td>
<td> R/W
</td></tr>
<tr>
<th> Initialwert
</th>
<td> 0 </td>
<td> 0 </td>
<td> 0 </td>
<td> 0 </td>
<td> 0 </td>
<td> 0 </td>
<td> 0 </td>
<td> 0
</td></tr></tbody></table>
<p><b>SE</b> (<b>S</b>leep <b>E</b>nable)
</p>
<dl>
<dd>Dieses Bit muss gesetzt sein, um den Controller mit dem <b>SLEEP</b>-Befehl in den Schlafzustand versetzen zu können.
</dd>
<dd>Um den Schlafmodus nicht irrtümlich einzuschalten, wird empfohlen, das Bit erst unmittelbar vor Ausführung des <b>SLEEP</b>-Befehls zu setzen.
</dd>
</dl>
<p><b>SM</b> (<b>S</b>leep <b>M</b>ode)
</p>
<dl>
<dd>Dieses Bit bestimmt über den Schlafmodus.
</dd>
<dd>Ist das Bit gelöscht, so wird der <b>Idle</b>-Modus ausgeführt. Ist das Bit gesetzt, so wird der <b>Power-Down</b>-Modus ausgeführt. (für andere AVR Controller siehe Abschnitt "Sleep-Mode")
</dd>
</dl>
<p><b>ISC11</b>, <b>ISC10</b> (<b>I</b>nterrupt <b>S</b>ense <b>C</b>ontrol <b>1</b> Bits)
</p>
<dl>
<dd>Diese beiden Bits bestimmen, ob die steigende oder die fallende Flanke für die Interrupterkennung am <b>INT1</b>-Pin ausgewertet wird.
</dd>
</dl>
<dl><dd><table class="wikitable">

<tbody><tr>
<th> ISC11 </th>
<th> ISC10 </th>
<th> Bedeutung
</th></tr>
<tr>
<td align="center"> 0
</td>
<td align="center"> 0
</td>
<td> Low Level an <b>INT1</b> erzeugt einen Interrupt.
<p>Der Interrupt wird getriggert, solange der Pin auf 0 bleibt.
</p>
</td></tr>
<tr>
<td align="center"> 0
</td>
<td align="center"> 1
</td>
<td> Reserviert
</td></tr>
<tr>
<td align="center"> 1
</td>
<td align="center"> 0
</td>
<td> Die fallende Flanke an <b>INT1</b> erzeugt einen Interrupt.
</td></tr>
<tr>
<td align="center"> 1
</td>
<td align="center"> 1
</td>
<td> Die steigende Flanke an <b>INT1</b> erzeugt einen Interrupt.
</td></tr></tbody></table></dd></dl>
<p><b>ISC01</b>, <b>ISC00</b> (<b>I</b>nterrupt <b>S</b>ense <b>C</b>ontrol <b>0</b> Bits)
</p>
<dl>
<dd>Diese beiden Bits bestimmen, ob die steigende oder die fallende Flanke für die Interrupterkennung am <b>INT0</b>-Pin ausgewertet wird.
</dd>
</dl>
<dl><dd><table class="wikitable">

<tbody><tr>
<th> ISC01 </th>
<th> ISC00 </th>
<th> Bedeutung
</th></tr>
<tr>
<td align="center"> 0
</td>
<td align="center"> 0
</td>
<td> Low Level an <b>INT0</b> erzeugt einen Interrupt.
<p>Der Interrupt wird getriggert, solange der Pin auf 0 bleibt.
</p>
</td></tr>
<tr>
<td align="center"> 0
</td>
<td align="center"> 1
</td>
<td> Reserviert
</td></tr>
<tr>
<td align="center"> 1
</td>
<td align="center"> 0
</td>
<td> Die fallende Flanke an <b>INT0</b> erzeugt einen Interrupt.
</td></tr>
<tr>
<td align="center"> 1
</td>
<td align="center"> 1
</td>
<td> Die steigende Flanke an <b>INT0</b> erzeugt einen Interrupt.
</td></tr></tbody></table></dd></dl>
</td></tr></tbody></table>
<h2><span class="mw-headline" id="Allgemeines_.C3.BCber_die_Interrupt-Abarbeitung">Allgemeines über die Interrupt-Abarbeitung</span></h2>
<p>Wenn ein Interrupt eintrifft, wird automatisch das <b>Global Interrupt Enable</b> Bit im Status Register <b>SREG</b> gelöscht und alle weiteren Interrupts unterbunden. Dieses wird automatisch wieder gesetzt, wenn die Interruptroutine beendet wird. Wenn in der Zwischenzeit weitere Interrupts eintreffen, werden die zugehörigen Interrupt-Bits gesetzt und die Interrupts bei Beendigung der laufenden Interrupt-Routine in der Reihenfolge ihrer Priorität ausgeführt. Dies kann
eigentlich nur dann zu Problemen führen, wenn ein hoch priorisierter Interrupt ständig und in kurzer Folge auftritt. Dieser sperrt dann möglicherweise alle anderen Interrupts mit niedrigerer Priorität. Dies ist einer der Gründe, weshalb die Interrupt-Routinen sehr kurz gehalten werden sollen.  Es ist möglich das GIE-Bit in der ISR zu setzen und so schon wieder weitere Interrupts zuzulassen - allerdings sollte man damit vorsichtig sein und genau wissen was man damit macht. Kritisch wird es vor allem wenn der gleiche Interrupt noch einmal kommt, bevor die ISR abgearbeitet ist. 
</p><p><br>
</p>
<h2><span class="mw-headline" id="Interrupts_mit_avr-gcc">Interrupts mit avr-gcc</span></h2>
<p>Funktionen zur Interrupt-Verarbeitung werden in den Includedateien <i>interrupt.h</i>  der avr-libc zur Verfügung gestellt (bei älterem Quellcode zusätzlich <i>signal.h</i>).
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co1">// fuer sei(), cli() und ISR():</span>
<span class="co2">#include &lt;avr/interrupt.h&gt;</span></pre></div></div>
<p>Das Makro <b>sei()</b> schaltet die Interrupts ein. Eigentlich wird nichts anderes gemacht, als das <b>Global Interrupt Enable</b> Bit im Status Register gesetzt.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1">    sei<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span></pre></div></div>
<p>Das Makro <b>cli()</b> schaltet die Interrupts aus, oder anders gesagt, das <b>Global Interrupt Enable</b> Bit im Status Register wird gelöscht.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1">    cli<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span></pre></div></div>
<p>Oft steht man vor der Aufgabe, dass eine Codesequenz nicht unterbrochen werden darf. Es liegt dann nahe, zu Beginn dieser Sequenz ein cli() und am Ende ein sei() einzufügen. Dies ist jedoch ungünstig, wenn die Interrupts vor Aufruf der Sequenz deaktiviert waren und danach auch weiterhin deaktiviert bleiben sollen. Ein sei() würde ungeachtet des vorherigen  Zustands die Interrupts aktivieren, was zu unerwünschten Seiteneffekten führen kann. Die aus dem folgenden Beispiel ersichtliche Vorgehensweise ist in solchen Fällen vorzuziehen:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/io.h&gt;</span>
<span class="co2">#include &lt;avr/interrupt.h&gt;</span>
<span class="co2">#include &lt;inttypes.h&gt;</span>
&nbsp;
<span class="co1">//...</span>
&nbsp;
<span class="kw4">void</span> NichtUnterbrechenBitte<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span>
<span class="br0">{</span>
   <span class="kw4">uint8_t</span> tmp_sreg<span class="sy0">;</span>  <span class="co1">// temporaerer Speicher fuer das Statusregister</span>
&nbsp;
   tmp_sreg <span class="sy0">=</span> SREG<span class="sy0">;</span>   <span class="co1">// Statusregister (also auch das I-Flag darin) sichern</span>
   cli<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>             <span class="co1">// Interrupts global deaktivieren</span>
&nbsp;
   <span class="coMULTI">/* hier "unterbrechnungsfreier" Code */</span>
&nbsp;
   <span class="coMULTI">/* Beispiel Anfang
     JTAG-Interface eines ATmega16 per Software deaktivieren 
     und damit die JTAG-Pins an PORTC für "general I/O" nutzbar machen
     ohne die JTAG-Fuse-Bit zu aendern. Dazu ist eine "timed sequence"
     einzuhalten (vgl Datenblatt ATmega16, Stand 10/04, S. 229): 
     Das JTD-Bit muss zweimal innerhalb von 4 Taktzyklen geschrieben 
     werden. Ein Interrupt zwischen den beiden Schreibzugriffen wuerde 
     die erforderliche Sequenz "brechen", das JTAG-Interface bliebe
     weiterhin aktiv und die IO-Pins weiterhin für JTAG reserviert. */</span>
&nbsp;
   MCUCSR <span class="sy0">|=</span> <span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>JTD<span class="br0">)</span><span class="sy0">;</span>
   MCUCSR <span class="sy0">|=</span> <span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>JTD<span class="br0">)</span><span class="sy0">;</span> <span class="co1">// 2 mal in Folge ,vgl. Datenblatt fuer mehr Information</span>
&nbsp;
   <span class="coMULTI">/* Beispiel Ende */</span>
&nbsp;
   SREG <span class="sy0">=</span> tmp_sreg<span class="sy0">;</span>     <span class="co1">// Status-Register wieder herstellen </span>
                      <span class="co1">// somit auch das I-Flag auf gesicherten Zustand setzen</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">void</span> NichtSoGut<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span>
<span class="br0">{</span>
   cli<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
   <span class="coMULTI">/* hier "unterbrechnungsfreier" Code */</span>
&nbsp;
   sei<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
&nbsp;
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span>
<span class="br0">{</span>
   <span class="co1">//...</span>
&nbsp;
   cli<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>  
   <span class="co1">// Interrupts global deaktiviert </span>
&nbsp;
   NichtUnterbrechenBitte<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
   <span class="co1">// auch nach Aufruf der Funktion deaktiviert</span>
&nbsp;
   sei<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
   <span class="co1">// Interrupts global aktiviert </span>
&nbsp;
   NichtUnterbrechenBitte<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
   <span class="co1">// weiterhin aktiviert</span>
   <span class="co1">//...</span>
&nbsp;
   <span class="coMULTI">/* Verdeutlichung der unguenstigen Vorgehensweise mit cli/sei: */</span>
   cli<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>  
   <span class="co1">// Interrupts jetzt global deaktiviert </span>
&nbsp;
   NichtSoGut<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
   <span class="co1">// nach Aufruf der Funktion sind Interrupts global aktiviert </span>
   <span class="co1">// dies ist mglw. ungewollt!</span>
   <span class="co1">//...</span>
&nbsp;
<span class="br0">}</span></pre></div></div>
<p><br>
Zu den aktivierten Interrupts ist eine Funktion zu programmieren, deren Code aufgerufen wird, wenn der betreffende Interrupt auftritt (Interrupt-Handler, Interrupt-Service-Routine). Dazu existiert die Definition (ein Makro) <b>ISR</b>.
</p>
<h3><span class="mw-headline" id="ISR">ISR</span></h3>
<p>(<i>ISR()</i> ersetzt bei neueren Versionen der avr-libc <i>SIGNAL()</i>. SIGNAL sollte nicht mehr genutzt werden, zur Portierung von SIGNAL nach ISR siehe den <a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#Anhang" title="AVR-GCC-Tutorial">Anhang</a>.)
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/interrupt.h&gt;</span>
<span class="co1">//...</span>
ISR<span class="br0">(</span>Vectorname<span class="br0">)</span> <span class="coMULTI">/* vormals: SIGNAL(siglabel) dabei Vectorname&nbsp;!= siglabel&nbsp;! */</span>
<span class="br0">{</span>
    <span class="coMULTI">/* Interrupt Code */</span>
<span class="br0">}</span></pre></div></div>
<p>Mit <i>ISR</i> wird eine Funktion für die Bearbeitung eines Interrupts eingeleitet. Als Argument muss dabei die Benennung des entsprechenden Interruptvektors angegeben werden. Diese sind in den jeweiligen Includedateien IOxxxx.h zu finden. Die Bezeichnung entspricht dem Namen aus dem Datenblatt, bei dem die Leerzeichen durch Unterstriche ersetzt sind und ein <i>_vect</i> angehängt ist.
</p><p>Als Beispiel ein Ausschnitt aus der Datei für den ATmega8 (bei WinAVR Standardinstallation in C:\WinAVR\avr\include\avr\iom8.h) in der neben den aktuellen Namen für <i>ISR</i> (*_vect) noch die Bezeichnungen für das inzwischen nicht mehr aktuelle <i>SIGNAL</i> (SIG_*) enthalten sind.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co1">//...</span>
<span class="coMULTI">/* $Id: iom8.h,v 1.13 2005/10/30 22:11:23 joerg_wunsch Exp $ */</span>
&nbsp;
<span class="coMULTI">/* avr/iom8.h  - definitions for ATmega8 */</span>
<span class="co1">//...</span>
&nbsp;
<span class="coMULTI">/* Interrupt vectors */</span>
&nbsp;
<span class="coMULTI">/* External Interrupt Request 0 */</span>
<span class="co2">#define INT0_vect                       _VECTOR(1)</span>
<span class="co2">#define SIG_INTERRUPT0                  _VECTOR(1)</span>
&nbsp;
<span class="coMULTI">/* External Interrupt Request 1 */</span>
<span class="co2">#define INT1_vect                       _VECTOR(2)</span>
<span class="co2">#define SIG_INTERRUPT1                  _VECTOR(2)</span>
&nbsp;
<span class="coMULTI">/* Timer/Counter2 Compare Match */</span>
<span class="co2">#define TIMER2_COMP_vect                _VECTOR(3)</span>
<span class="co2">#define SIG_OUTPUT_COMPARE2             _VECTOR(3)</span>
&nbsp;
<span class="coMULTI">/* Timer/Counter2 Overflow */</span>
<span class="co2">#define TIMER2_OVF_vect                 _VECTOR(4)</span>
<span class="co2">#define SIG_OVERFLOW2                   _VECTOR(4)</span>
&nbsp;
<span class="coMULTI">/* Timer/Counter1 Capture Event */</span>
<span class="co2">#define TIMER1_CAPT_vect                _VECTOR(5)</span>
<span class="co2">#define SIG_INPUT_CAPTURE1              _VECTOR(5)</span>
&nbsp;
<span class="coMULTI">/* Timer/Counter1 Compare Match A */</span>
<span class="co2">#define TIMER1_COMPA_vect               _VECTOR(6)</span>
<span class="co2">#define SIG_OUTPUT_COMPARE1A            _VECTOR(6)</span>
&nbsp;
<span class="coMULTI">/* Timer/Counter1 Compare Match B */</span>
<span class="co2">#define TIMER1_COMPB_vect               _VECTOR(7)</span>
<span class="co2">#define SIG_OUTPUT_COMPARE1B            _VECTOR(7)</span>
&nbsp;
<span class="co1">//...</span></pre></div></div>
<p>Mögliche Funktionsrümpfe für Interruptfunktionen sind zum Beispiel:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/interrupt.h&gt;</span>
<span class="coMULTI">/* veraltet: #include &lt;avr/signal.h&gt; */</span>
&nbsp;
ISR<span class="br0">(</span>INT0_vect<span class="br0">)</span>       <span class="coMULTI">/* veraltet: SIGNAL(SIG_INTERRUPT0) */</span>
<span class="br0">{</span>
    <span class="coMULTI">/* Interrupt Code */</span>
<span class="br0">}</span>
&nbsp;
ISR<span class="br0">(</span>TIMER0_OVF_vect<span class="br0">)</span> <span class="coMULTI">/* veraltet: SIGNAL(SIG_OVERFLOW0) */</span>
<span class="br0">{</span>
    <span class="coMULTI">/* Interrupt Code */</span>
<span class="br0">}</span>
&nbsp;
ISR<span class="br0">(</span>USART_RXC_vect<span class="br0">)</span> <span class="coMULTI">/* veraltet: SIGNAL(SIG_UART_RECV) */</span>
<span class="br0">{</span>
    <span class="coMULTI">/* Interrupt Code */</span>
<span class="br0">}</span>
&nbsp;
<span class="co1">// und so weiter und so fort...</span></pre></div></div>
<p>Auf die korrekte Schreibweise der Vektorbezeichnung ist zu achten. Der gcc-Compiler prüft erst ab Version 4.x, ob ein Signal/Interrupt der angegebenen Bezeichnung tatsächlich in der Includedatei definiert ist und gibt andernfalls eine Warnung aus. Bei WinAVR (ab 2/2005) wurde die Überprüfung auch in den mitgelieferten Compiler der Version 3.x integriert. Aus dem gcc-Quellcode Version 3.x selbst erstellte Compiler enthalten die Prüfung nicht (vgl. <a href="http://www.mikrocontroller.net/articles/AVR-GCC" title="AVR-GCC">AVR-GCC</a>). 
</p><p>Während der Ausführung der Funktion sind alle weiteren Interrupts automatisch gesperrt. Beim Verlassen der Funktion werden die Interrupts wieder zugelassen.
</p><p>Sollte während der Abarbeitung der Interruptroutine ein weiterer Interrupt (gleiche oder andere Interruptquelle) auftreten, so wird das entsprechende Bit im zugeordneten Interrupt Flag Register gesetzt und die entsprechende Interruptroutine automatisch nach dem Beenden der aktuellen Funktion aufgerufen.
</p><p>Ein Problem ergibt sich eigentlich nur dann, wenn während der Abarbeitung der aktuellen Interruptroutine mehrere gleichartige Interrupts auftreten. Die entsprechende Interruptroutine wird im Nachhinein zwar aufgerufen jedoch wissen wir nicht, ob nun der entsprechende Interrupt einmal, zweimal oder gar noch öfter aufgetreten ist. Deshalb soll hier noch einmal betont werden, dass Interruptroutinen so schnell wie nur irgend möglich wieder verlassen werden sollten.
</p>
<h3><span class="mw-headline" id="Unterbrechbare_Interruptroutinen">Unterbrechbare Interruptroutinen</span></h3>
<p>"Faustregel": im Zweifel <b>ISR</b>. Die nachfolgend beschriebene Methode nur dann verwenden, wenn man sich über die unterschiedliche Funktionsweise im Klaren ist.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/interrupt.h&gt;</span>
&nbsp;
ISR<span class="br0">(</span>XXX<span class="sy0">,</span>ISR_NOBLOCK<span class="br0">)</span> <span class="coMULTI">/* veraltet: INTERRUPT(SIG_OVERFLOW0) */</span>
<span class="br0">{</span>
    <span class="coMULTI">/* Interrupt-Code */</span>
<span class="br0">}</span></pre></div></div>
<p>Hierbei steht XXX für den oben beschriebenen Namen des Vektors (also z.&nbsp;B. <i>TIMER0_OVF_vect</i>). Der Unterschied im Vergleich zu einer herkömmlichen ISR ist, dass hier beim Aufrufen der Funktion das <b>Global Enable Interrupt</b> Bit durch Einfügen einer SEI-Anweisung direkt wieder gesetzt und somit alle Interrupts zugelassen werden – auch XXX-Interrupts. 
</p><p>Bei unsachgemässer Handhabung kann dies zu erheblichen Problemen durch Rekursion wie einem Stack-Overflow oder anderen unerwarteten Effekten führen und sollte wirklich nur dann eingesetzt werden, wenn man sich sicher ist, das Ganze auch im Griff zu haben.
</p><p>Insbesondere sollte möglichst am ISR-Anfang die auslösende IRQ-Quelle deaktiviert und erst am Ende der ISR wieder aktiviert werden. Robuster als die Verwendung einer NOBLOCK-ISR ist daher folgender ISR-Aufbau:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/interrupt.h&gt;</span>
&nbsp;
ISR <span class="br0">(</span>XXX<span class="br0">)</span> 
<span class="br0">{</span>
    <span class="co1">// Implementiere die ISR ohne zunaechst weitere IRQs zuzulassen</span>
&nbsp;
    <span class="sy0">&lt;&lt;</span>Deaktiviere die XXX<span class="sy0">-</span>IRQ<span class="sy0">&gt;&gt;</span>
&nbsp;
    <span class="co1">// Erlaube alle Interrupts (ausser XXX)</span>
    sei<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">//... Code ...</span>
&nbsp;
    <span class="co1">// IRQs global deaktivieren um die XXX-IRQ wieder gefahrlos </span>
    <span class="co1">// aktivieren zu koennen</span>
    cli<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="sy0">&lt;&lt;</span>Aktiviere die XXX<span class="sy0">-</span>IRQ<span class="sy0">&gt;&gt;</span>
<span class="br0">}</span></pre></div></div>
<p>Auf diese Weise kann sich die XXX-IRQ nicht selbst unterbrechen, was zu einer Art Endlosschleife führen würde.
</p><p>Siehe auch: Hinweise in <a href="http://www.mikrocontroller.net/articles/AVR-GCC" title="AVR-GCC">AVR-GCC</a>
</p><p>siehe dazu: <a rel="nofollow" class="external free" href="http://www.nongnu.org/avr-libc/user-manual/group__avr__interrupts.html">http://www.nongnu.org/avr-libc/user-manual/group__avr__interrupts.html</a>
</p>
<h2><span class="mw-headline" id="Datenaustausch_mit_Interrupt-Routinen">Datenaustausch mit Interrupt-Routinen</span></h2>
<p>Variablen, die sowohl in Interrupt-Routinen (ISR = Interrupt Service Routine(s)) als auch vom übrigen Programmcode geschrieben oder gelesen werden, müssen mit einem <b>volatile</b> deklariert werden. Damit wird dem Compiler mitgeteilt, dass der Inhalt der Variablen vor jedem Lesezugriff aus dem Speicher gelesen und nach jedem Schreibzugriff in den Speicher geschrieben wird. Ansonsten könnte der Compiler den Code so optimieren, dass der Wert der Variablen nur in Prozessorregistern zwischengespeichert wird, die nichts von der Änderung woanders mitbekommen.
</p><p>Zur Veranschaulichung ein Codefragment für eine Tastenentprellung mit Erkennung einer "lange gedrückten" Taste.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/io.h&gt;</span>
<span class="co2">#include &lt;avr/interrupt.h&gt;</span>
<span class="co2">#include &lt;stdint.h&gt;</span>
<span class="co1">//...</span>
&nbsp;
<span class="co1">// Schwellwerte</span>
<span class="co1">// Entprellung: </span>
<span class="co2">#define CNTDEBOUNCE 10</span>
<span class="co1">// "lange gedrueckt:"</span>
<span class="co2">#define CNTREPEAT 200</span>
&nbsp;
<span class="co1">// hier z.&amp;nbsp;B. Taste an Pin2 PortA "active low" = 0 wenn gedrueckt</span>
<span class="co2">#define KEY_PIN  PINA</span>
<span class="co2">#define KEY_PINNO PA2</span>
&nbsp;
<span class="co1">// beachte: volatile! </span>
<span class="kw4">volatile</span> <span class="kw4">uint8_t</span> gKeyCounter<span class="sy0">;</span>
&nbsp;
<span class="co1">// Timer-Compare Interrupt ISR, wird z.B. alle 10ms ausgefuehrt</span>
ISR<span class="br0">(</span>TIMER1_COMPA_vect<span class="br0">)</span>
<span class="br0">{</span>
   <span class="co1">// hier wird gKeyCounter veraendert. Die übrigen</span>
   <span class="co1">// Programmteile müssen diese Aenderung "sehen":</span>
   <span class="co1">// volatile -&gt; aktuellen Wert immer in den Speicher schreiben</span>
   <span class="kw1">if</span> <span class="br0">(</span> <span class="sy0">!</span><span class="br0">(</span>KEY_PIN <span class="sy0">&amp;</span> <span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>KEY_PINNO<span class="br0">)</span><span class="br0">)</span> <span class="br0">)</span> <span class="br0">{</span>
      <span class="kw1">if</span> <span class="br0">(</span>gKeyCounter <span class="sy0">&lt;</span> CNTREPEAT<span class="br0">)</span> gKeyCounter<span class="sy0">++;</span>
   <span class="br0">}</span>
   <span class="kw1">else</span> <span class="br0">{</span>
      gKeyCounter <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
   <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="co1">//...</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span>
<span class="br0">{</span>
<span class="co1">//...</span>
    <span class="coMULTI">/* hier: Initialisierung der Ports und des Timer-Interrupts */</span>
<span class="co1">//... </span>
   <span class="co1">// hier wird auf gKeyCounter zugegriffen. Dazu muss der in der</span>
   <span class="co1">// ISR geschriebene Wert bekannt sein:</span>
   <span class="co1">// volatile -&gt; aktuellen Wert immer aus dem Speicher lesen</span>
   <span class="kw1">if</span> <span class="br0">(</span> gKeyCounter <span class="sy0">&gt;</span> CNTDEBOUNCE <span class="br0">)</span> <span class="br0">{</span> <span class="co1">// Taste mind. 10*10 ms "prellfrei"</span>
       <span class="kw1">if</span> <span class="br0">(</span>gKeyCounter <span class="sy0">==</span> CNTREPEAT<span class="br0">)</span> <span class="br0">{</span>
          <span class="coMULTI">/* hier: Code fuer "Taste lange gedrueckt" */</span>
       <span class="br0">}</span>
       <span class="kw1">else</span> <span class="br0">{</span>
          <span class="coMULTI">/* hier: Code fuer "Taste kurz gedrueckt" */</span>
       <span class="br0">}</span>
   <span class="br0">}</span>
<span class="co1">//...</span>
<span class="br0">}</span></pre></div></div>
<p>Wird innerhalb einer ISR mehrfach auf eine mit volatile deklarierte Variable zugegriffen, wirkt sich dies ungünstig auf die Verarbeitungsgeschwindigkeit aus, da bei jedem Zugriff mit dem Speicherinhalt abgeglichen wird. Da bei AVR-Controllern <i>innerhalb</i> einer ISR keine Unterbrechungen zu erwarten sind, bietet es sich an, einen Zwischenspeicher in Form einer lokalen Variable zu verwenden, deren Inhalt zu Beginn und am Ende mit dem der volatile Variable synchronisiert wird. Lokale Variable werden bei eingeschalteter Optimierung mit hoher Wahrscheinlichkeit in Prozessorregistern verwaltet und der Zugriff darauf ist daher nur mit wenigen internen Operationen verbunden. Die ISR aus dem vorherigen Beispiel lässt sich so optimieren:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co1">//...</span>
ISR<span class="br0">(</span>TIMER1_COMPA_vect<span class="br0">)</span>
<span class="br0">{</span>
   <span class="kw4">uint8_t</span> tmp_kc<span class="sy0">;</span>
&nbsp;
   tmp_kc <span class="sy0">=</span> gKeyCounter<span class="sy0">;</span> <span class="co1">// Uebernahme in lokale Arbeitsvariable</span>
&nbsp;
   <span class="kw1">if</span> <span class="br0">(</span> <span class="sy0">!</span><span class="br0">(</span>KEY_PIN <span class="sy0">&amp;</span> <span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>KEY_PINNO<span class="br0">)</span><span class="br0">)</span> <span class="br0">)</span> <span class="br0">{</span>
      <span class="kw1">if</span> <span class="br0">(</span>tmp_kc <span class="sy0">&lt;</span> CNTREPEAT<span class="br0">)</span> <span class="br0">{</span>
         tmp_kc<span class="sy0">++;</span>
      <span class="br0">}</span>
   <span class="br0">}</span>
   <span class="kw1">else</span> <span class="br0">{</span>
      tmp_kc <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
   <span class="br0">}</span>
&nbsp;
   gKeyCounter <span class="sy0">=</span> tmp_kc<span class="sy0">;</span> <span class="co1">// Zurueckschreiben</span>
<span class="br0">}</span>
<span class="co1">//...</span></pre></div></div>
<p>Zum Vergleich die Disassemblies (Ausschnitte der "lss-Dateien", compiliert für ATmega162) im Anschluss. Man erkennt den viermaligen Zugriff auf die Speicheraddresse von <i>gKeyCounter</i> (hier 0x032A) in der ISR ohne "Cache"-Variable und den zweimaligen Zugriff in der Variante mit Zwischenspeicher. Im Beispiel ist der Vorteil gering, bei komplexeren Routinen kann die Zwischenspeicherung in lokalen Variablen jedoch zu deutlicheren Verbesserungen führen.
</p>
<pre>ISR(TIMER1_COMPA_vect)
{
     86a:	1f 92       	push	r1
     86c:	0f 92       	push	r0
     86e:	0f b6       	in	r0, 0x3f	; 63
     870:	0f 92       	push	r0
     872:	11 24       	eor	r1, r1
     874:	8f 93       	push	r24
    if (&nbsp;!(KEY_PIN &amp; (1&lt;&lt;KEY_PINNO)) ) {
     876:	ca 99       	sbic	0x19, 2	; 25
     878:	0a c0       	rjmp	.+20     	; 0x88e &lt;__vector_13+0x24&gt;
      if (gKeyCounter &lt; CNTREPEAT) gKeyCounter++;
     87a:	80 91 2a 03 	lds	r24, 0x032A
     87e:	88 3c       	cpi	r24, 0xC8	; 200 
     880:	40 f4       	brcc	.+16     	; 0x892 &lt;__vector_13+0x28&gt;
     882:	80 91 2a 03 	lds	r24, 0x032A
     886:	8f 5f       	subi	r24, 0xFF	; 255
     888:	80 93 2a 03 	sts	0x032A, r24
     88c:	02 c0       	rjmp	.+4      	; 0x892 &lt;__vector_13+0x28&gt;
   }
   else {
      gKeyCounter = 0;
     88e:	10 92 2a 03 	sts	0x032A, r1
     892:	8f 91       	pop	r24
     894:	0f 90       	pop	r0
     896:	0f be       	out	0x3f, r0	; 63
     898:	0f 90       	pop	r0
     89a:	1f 90       	pop	r1
     89c:	18 95       	reti
</pre>
<pre>ISR(TIMER1_COMPA_vect)
{
     86a:	1f 92       	push	r1
     86c:	0f 92       	push	r0
     86e:	0f b6       	in	r0, 0x3f	; 63
     870:	0f 92       	push	r0
     872:	11 24       	eor	r1, r1
     874:	8f 93       	push	r24
   uint8_t tmp_kc;
 
   tmp_kc = gKeyCounter;
     876:	80 91 2a 03 	lds	r24, 0x032A
 
   if (&nbsp;!(KEY_PIN &amp; (1&lt;&lt;KEY_PINNO)) ) {
     87a:	ca 9b       	sbis	0x19, 2	; 25
     87c:	02 c0       	rjmp	.+4      	; 0x882 &lt;__vector_13+0x18&gt;
     87e:	80 e0       	ldi	r24, 0x00	; 0
     880:	03 c0       	rjmp	.+6      	; 0x888 &lt;__vector_13+0x1e&gt;
      if (tmp_kc &lt; CNTREPEAT) {
     882:	88 3c       	cpi	r24, 0xC8	; 200
     884:	08 f4       	brcc	.+2      	; 0x888 &lt;__vector_13+0x1e&gt;
         tmp_kc++;
     886:	8f 5f       	subi	r24, 0xFF	; 255
      }
   }
   else {
      tmp_kc = 0;
   }
 
   gKeyCounter = tmp_kc;
     888:	80 93 2a 03 	sts	0x032A, r24
     88c:	8f 91       	pop	r24
     88e:	0f 90       	pop	r0
     890:	0f be       	out	0x3f, r0	; 63
     892:	0f 90       	pop	r0
     894:	1f 90       	pop	r1
     896:	18 95       	reti
</pre>
<h3><span class="mw-headline" id="volatile_und_Pointer">volatile und Pointer</span></h3>
<p>Bei <b>volatile</b> in Verbindung mit Pointern ist zu beachten, ob der Pointer selbst oder die Variable, auf die der Pointer zeigt, <b>volatile</b> ist.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">volatile</span> <span class="kw4">uint8_t</span> <span class="sy0">*</span>a<span class="sy0">;</span>   <span class="co1">// das Ziel von a ist volatile</span>
&nbsp;
<span class="kw4">uint8_t</span> <span class="sy0">*</span><span class="kw4">volatile</span> a<span class="sy0">;</span>   <span class="co1">// a selbst ist volatile</span></pre></div></div>
<p>Falls der Pointer volatile ist (zweiter Fall im Beispiel), ist zu beachten, dass der Wert des Pointers, also eine Speicheradresse, intern in mehr als einem Byte verwaltet wird. Lese- und Schreibzugriffe im Hauptprogramm (außerhalb von Interrupt-Routinen) sind daher so zu implementieren, dass alle Teilbytes der Adresse konsistent bleiben, vgl. dazu den folgenden Abschnitt.
</p>
<h3><span class="mw-headline" id="Variablen_gr.C3.B6.C3.9Fer_1_Byte">Variablen größer 1 Byte</span></h3>
<p>Bei Variablen größer ein Byte, auf die in Interrupt-Routinen und im Hauptprogramm zugegriffen wird, muss darauf geachtet werden, dass die Zugriffe auf die einzelnen Bytes außerhalb der ISR nicht durch einen Interrupt unterbrochen werden. (Allgemeinplatz: AVRs sind 8-bit Controller). Zur Veranschaulichung ein Codefragment:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co1">//...</span>
<span class="kw4">volatile</span> <span class="kw4">uint16_t</span> gMyCounter16bit<span class="sy0">;</span>
<span class="co1">//...</span>
ISR<span class="br0">(</span>...<span class="br0">)</span>
<span class="br0">{</span>
<span class="co1">//...</span>
   gMyCounter16Bit<span class="sy0">++;</span>
<span class="co1">//...</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span>
<span class="br0">{</span>
   <span class="kw4">uint16_t</span> tmpCnt<span class="sy0">;</span>
<span class="co1">//...</span>
   <span class="co1">// nicht gut: Mglw. hier ein Fehler, wenn ein Byte von MyCounter </span>
   <span class="co1">// schon in tmpCnt kopiert ist aber vor dem Kopieren des zweiten Bytes </span>
   <span class="co1">// ein Interrupt auftritt, der den Inhalt von MyCounter verändert.</span>
   tmpCnt <span class="sy0">=</span> gMyCounter16bit<span class="sy0">;</span> 
&nbsp;
&nbsp;
   <span class="co1">// besser: Änderungen "außerhalb" verhindern -&gt; alle "Teilbytes"</span>
   <span class="co1">// bleiben konsistent</span>
   cli<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>  <span class="co1">// Interrupts deaktivieren</span>
   tmpCnt <span class="sy0">=</span> gMyCounter16Bit<span class="sy0">;</span>
   sei<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>  <span class="co1">// wieder aktivieren</span>
&nbsp;
   <span class="co1">// oder: vorheriger Status des globalen Interrupt-Flags bleibt erhalten</span>
   <span class="kw4">uint8_t</span> sreg_tmp<span class="sy0">;</span>
   sreg_tmp <span class="sy0">=</span> SREG<span class="sy0">;</span>    <span class="coMULTI">/* Sichern */</span>
   cli<span class="br0">(</span><span class="br0">)</span>
   tmpCnt <span class="sy0">=</span> gMyCounter16Bit<span class="sy0">;</span>
   SREG <span class="sy0">=</span> sreg_tmp<span class="sy0">;</span>    <span class="coMULTI">/* Wiederherstellen */</span>
&nbsp;
   <span class="co1">// oder: mehrfach lesen, bis man konsistente Daten hat</span>
   <span class="kw4">uint16_t</span> count1 <span class="sy0">=</span> gMyCounter16Bit<span class="sy0">;</span>
   <span class="kw4">uint16_t</span> count2 <span class="sy0">=</span> gMyCounter16Bit<span class="sy0">;</span>
   <span class="kw1">while</span> <span class="br0">(</span>count1 <span class="sy0">!=</span> count2<span class="br0">)</span> <span class="br0">{</span>
       count1 <span class="sy0">=</span> count2<span class="sy0">;</span>
       count2 <span class="sy0">=</span> gMyCounter16Bit<span class="sy0">;</span>
   <span class="br0">}</span>
   tmpCnt <span class="sy0">=</span> count1<span class="sy0">;</span>
<span class="co1">//...</span>
<span class="br0">}</span></pre></div></div>
<p>Die avr-libc bietet ab Version 1.6.0(?) einige Hilfsfunktionen/Makros, mit der im Beispiel oben gezeigten Funktionalität, die zusätzlich auch sogenannte <a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Memory_barrier">memory barriers</a> beinhalten. Diese stehen nach #include &lt;util/atomic.h&gt; zur Verfügung.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co1">//...</span>
<span class="co2">#include &lt;util/atomic.h&gt;</span>
<span class="co1">//...</span>
&nbsp;
    <span class="co1">// analog zu cli, Zugriff, sei:</span>
    ATOMIC_BLOCK<span class="br0">(</span>ATOMIC_FORCEON<span class="br0">)</span> <span class="br0">{</span>
        tmpCnt <span class="sy0">=</span> gMyCounter16Bit<span class="sy0">;</span>
    <span class="br0">}</span>
&nbsp;
<span class="co1">// oder:</span>
&nbsp;
    <span class="co1">// analog zu Sicherung des SREG, cli, Zugriff und Zurückschreiben des SREG:</span>
    ATOMIC_BLOCK<span class="br0">(</span>ATOMIC_RESTORESTATE<span class="br0">)</span> <span class="br0">{</span>
        tmpCnt <span class="sy0">=</span> gMyCounter16Bit<span class="sy0">;</span>
    <span class="br0">}</span>
&nbsp;
<span class="co1">//...</span></pre></div></div>
<ul>
<li> siehe auch <a rel="nofollow" class="external text" href="http://www.nongnu.org/avr-libc/user-manual/group__util__atomic.html">Dokumentation der avr-libc zu atomic.h</a>
</li>
</ul>
<h2><span class="mw-headline" id="Interrupt-Routinen_und_Registerzugriffe">Interrupt-Routinen und Registerzugriffe</span></h2>
<p>Falls Register sowohl im Hauptprogramm als auch in Interrupt-Routinen verändert werden, ist darauf zu achten, dass diese Zugriffe sich nicht überlappen. Nur wenige Anweisungen lassen sich in sogenannte "atomare" Zugriffe übersetzen, die nicht von Interrupt-Routinen unterbrochen werden können. 
</p><p>Zur Veranschaulichung eine Anweisung, bei der ein Bit und im Anschluss drei Bits in einem Register gesetzt werden:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/io.h&gt;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span>
<span class="br0">{</span>
<span class="co1">//...</span>
	PORTA <span class="sy0">|=</span> <span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>PA0<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	PORTA <span class="sy0">|=</span> <span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>PA2<span class="br0">)</span><span class="sy0">|</span><span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>PA3<span class="br0">)</span><span class="sy0">|</span><span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>PA4<span class="br0">)</span><span class="sy0">;</span>
<span class="co1">//...</span>
<span class="br0">}</span></pre></div></div>
<p>Der Compiler übersetzt diese Anweisungen für einen ATmega128 bei Optimierungsstufe "S" nach:
</p>
<div class="code"><pre>...
        PORTA |= (1&lt;&lt;PA0);
  d2:	d8 9a       	sbi	0x1b, 0	; 27 (a)
	
        PORTA |= (1&lt;&lt;PA2)|(1&lt;&lt;PA3)|(1&lt;&lt;PA4);
  d4:	8b b3       	in	r24, 0x1b	; 27 (b)
  d6:	8c 61       	ori	r24, 0x1C	; 28 (c)
  d8:	8b bb       	out	0x1b, r24	; 27 (d)
...
</pre></div>
<p>Das Setzen des einzelnen Bits wird bei eingeschalteter Optimierung für Register im unteren Speicherbereich in eine einzige Assembler-Anweisung (sbi) übersetzt und ist nicht anfällig für Unterbrechungen durch Interrupts. Die Anweisung zum Setzen von drei Bits wird jedoch in drei abhängige Assembler-Anweisungen übersetzt und bietet damit zwei "Angriffspunkte" für Unterbrechungen. Eine Interrupt-Routine könnte nach dem Laden des Ausgangszustands in den Zwischenspeicher (hier Register 24) den Wert des Registers ändern, z.&nbsp;B. ein Bit löschen. Damit würde der Zwischenspeicher nicht mehr mit dem tatsächlichen Zustand übereinstimmen aber dennoch nach der Bitoperation (hier ori) in das Register zurückgeschrieben. 
</p><p>Beispiel: PORTA sei anfangs 0b00000000. Die erste Anweisung (a) setzt Bit 0 auf <b>1</b>, PORTA ist danach 0b0000000<b>1</b>. Nun wird im ersten Teil der zweiten Anweisung der Portzustand in ein Register eingelesen (b). Unmittelbar darauf (vor (c)) "feuert" ein Interrupt, in dessen Interrupt-Routine Bit 0 von PORTA gelöscht wird. Nach Verlassen der Interrupt-Routine hat PORTA den Wert 0b00000000. In den beiden noch folgenden Anweisungen des Hauptprogramms wird nun der zwischengespeicherte "alte" Zustand 0b00000001 mit 0b00011100 logisch-<b>ODER</b>-verknüft (c) und das Ergebnis 0b00011101 in PortA geschrieben (d). Obwohl zwischenzeitlich Bit 0 gelöscht wurde, ist es nach (d) wieder gesetzt. 
</p><p>Lösungsmöglichkeiten:
</p>
<ul>
<li> Register ohne besondere Vorkehrungen nicht in Interruptroutinen <i>und</i> im Hauptprogramm verändern.
</li>
<li> Interrupts vor Veränderungen in Registern, die auch in ISRs verändert werden, deaktivieren ("cli").
</li>
<li> Bits einzeln löschen oder setzen. sbi und cbi können nicht unterbrochen werden. Vorsicht: nur Register im unteren Speicherbereich sind mittels sbi/cbi ansprechbar. Der Compiler kann nur für diese sbi/cbi-Anweisungen generieren. Für Register außerhalb dieses Adressbereichs ("Memory-Mapped"-Register) werden auch zur Manipulation einzelner Bits abhängige Anweisungen erzeugt (lds,...,sts).
</li>
</ul>
<ul>
<li> siehe auch: <a rel="nofollow" class="external text" href="http://www.nongnu.org/avr-libc/user-manual/index.html">Dokumentation der avr-libc</a> Frequently asked Questions/Fragen Nr. 1 und 8. (Stand: avr-libc Vers. 1.0.4)
</li>
</ul>
<h2><span class="mw-headline" id="Interruptflags_l.C3.B6schen">Interruptflags löschen</span></h2>
<p>Beim Löschen von Interruptflags haben AVRs eine Besonderheit, die auch im Datenblatt beschrieben ist: Es wird zum Löschen eine 1 in das betreffende Bit geschrieben. 
</p><p>Hinweis:<br>
Bei Registern mit mehreren Interrupt-Flag-Bits (wie die Timer Interrupt Flag Register)  <b>nicht</b>  die übliche bitweise VerODERung nehmen, sondern eine direkte Zuweisung machen. Da sonst weitere Flags, als nur das gewünschte, ebenfalls gelöscht werden könnten.<br>
(<a class="external text" href="http://www.mikrocontroller.net/topic/171148#1640133">Erklärung</a>).
</p>
<h2><span class="mw-headline" id="Was_macht_das_Hauptprogramm.3F">Was macht das Hauptprogramm?</span></h2>
<p>Im einfachsten (Ausnahme-)Fall gar nichts mehr. Es ist also durchaus denkbar, ein Programm zu schreiben, welches in der main-Funktion lediglich noch die Interrupts aktiviert und dann in einer Endlosschleife verharrt. Sämtliche Funktionen werden dann in den ISRs abgearbeitet. Diese Vorgehensweise ist jedoch bei den meisten Anwendungen schlecht: man verschenkt eine Verarbeitungsebene und hat außerdem möglicherweise Probleme durch Interruptroutinen, die zu viel Verarbeitungszeit benötigen.
</p><p>Normalerweise wird man in den Interruptroutinen nur die bei Auftreten des jeweiligen Interruptereignisses unbedingt notwendigen Operationen ausführen lassen. Alle weniger kritischen Aufgaben werden dann im Hauptprogramm abgearbeitet.
</p>
<ul>
<li> siehe auch: <a rel="nofollow" class="external text" href="http://www.nongnu.org/avr-libc/user-manual/index.html">Dokumentation der avr-libc</a> Abschnitt Modules/Interrupts and Signals
</li>
</ul>
<h1><span class="mw-headline" id="Sleep-Modes">Sleep-Modes</span></h1>
<p>AVR Controller verfügen über eine Reihe von sogenannten <a href="http://www.mikrocontroller.net/articles/Sleep_Mode" title="Sleep Mode"><i>Sleep-Modes</i></a> ("Schlaf-Modi"). Diese ermöglichen es, Teile des Controllers abzuschalten. Zum Einen kann damit besonders bei Batteriebetrieb Strom gespart werden, zum Anderen können Komponenten des Controllers deaktiviert werden, die die Genauigkeit des Analog-Digital-Wandlers bzw. des Analog-Comparators negativ beeinflussen. Der Controller wird durch Interrupts aus dem Schlaf geweckt. Welche Interrupts den jeweiligen Schlafmodus beenden, ist einer Tabelle im Datenblatt des jeweiligen Controllers zu entnehmen.
Die Funktionen (eigentlich Makros) der avr-libc stehen nach Einbinden der header-Datei <i>sleep.h</i> zur Verfügung.
</p>
<dl>
<dt>set_sleep_mode (uint8_t mode)</dt>
<dd> Setzt den Schlafmodus, der bei Aufruf von sleep() aktiviert wird. In sleep.h sind einige Konstanten definiert (z.&nbsp;B. SLEEP_MODE_PWR_DOWN). Die definierten Modi werden jedoch nicht alle von sämtlichten AVR-Controllern unterstützt.
</dd>
<dt>sleep_enable()</dt>
<dd> Aktiviert den gesetzten Schlafmodus, versetzt den Controller aber noch nicht in den Schlafmodus
</dd>
<dt>sleep_cpu()</dt>
<dd> Versetzt den Controller in den Schlafmodus .sleep_cpu wird im Prinzip durch die Assembler-Anweisung <i>sleep</i> ersetzt.
</dd>
<dt>sleep_disable()</dt>
<dd> Deaktiviert den gesetzten Schlafmodus
</dd>
<dt>sleep_mode()</dt>
<dd> Versetzt den Controller in den mit set_sleep_mode gewählten Schlafmodus. Das Makro entspricht sleep_enable()+sleep_cpu()+sleep_disable(), beinhaltet also nicht die Aktivierung von Interrupts (besser nicht benutzen).
</dd>
</dl>
<p>Bei Anwendung von sleep_cpu() müssen Interrupts also bereits freigeben sein (sei()), da der Controller sonst nicht mehr "aufwachen" kann. sleep_mode() ist nicht geeignet für die Verwendung in ISR Interrupt-Service-Routinen, da bei deren Abarbeitung Interrupts global deaktiviert sind und somit auch die möglichen "Aufwachinterrupts". Abhilfe: stattdessen sleep_enable(), sei(), sleep_cpu(), sleep_disable() und evtl. cli() verwenden (vgl. Dokumentation der avr-libc).
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/io.h&gt;</span>
<span class="co2">#include &lt;avr/sleep.h&gt;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span>
<span class="br0">{</span>
...
&nbsp;
   <span class="kw1">while</span> <span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span> <span class="br0">{</span>
...
      <span class="me1">set_sleep_mode</span><span class="br0">(</span>SLEEP_MODE_PWR_DOWN<span class="br0">)</span><span class="sy0">;</span>
      sleep_mode<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
      <span class="co1">// Code hier wird erst nach Auftreten eines entsprechenden</span>
      <span class="co1">// "Aufwach-Interrupts" verarbeitet</span>
...
   <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>In älteren Versionenen der avr-libc wurden nicht alle AVR-Controller durch die sleep-Funktionen richtig angesteuert. Mit avr-libc 1.2.0 wurde die Anzahl der unterstützten Typen jedoch deutlich erweitert. Bei nicht-unterstützten Typen erreicht man die gewünschte Funktionalität durch direkte "<a href="http://www.mikrocontroller.net/articles/Bitmanipulation" title="Bitmanipulation">Bitmanipulation</a>" der entsprechenden Register (vgl. Datenblatt) und Aufruf des Sleep-Befehls via Inline-Assembler oder sleep_cpu():
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/io.h&gt;</span>
...
   <span class="co1">// Sleep-Mode "Power-Save" beim ATmega169 "manuell" aktivieren</span>
   SMCR <span class="sy0">=</span> <span class="br0">(</span><span class="nu0">3</span><span class="sy0">&lt;&lt;</span>SM0<span class="br0">)</span> <span class="sy0">|</span> <span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>SE<span class="br0">)</span><span class="sy0">;</span>
   asm <span class="kw4">volatile</span> <span class="br0">(</span><span class="st0">"sleep"</span><span class="sy0">::</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// alternativ sleep_cpu() aus sleep.h</span>
...</pre></div></div>
<h2><span class="mw-headline" id="Sleep_Modi">Sleep Modi</span></h2>
<p>Zu beachten ist, dass unterschiedliche Prozessoren aus der AVR Familie unterschiedliche Sleep-Modi unterstützen oder nicht unterstützen. Auskunft über die tatsächlichen Gegebenheiten gibt, wie immer, das zum Prozessor gehörende Datenblatt. Die unterschiedlichen Modi unterscheiden sich dadurch, welche Bereiche des Prozessors abgeschaltet werden. Damit korrespondiert unmittelbar welche Möglichkeiten es gibt, den Prozessor aus den jeweiligen Sleep Modus wieder aufzuwecken.
</p>
<dl>
<dt>Idle Mode (SLEEP_MODE_IDLE)</dt>
<dd> Die CPU kann durch SPI, USART, Analog Comperator, ADC, TWI, Timer, Watchdog und irgendeinen anderen Interrupt wieder aufgeweckt werden.
</dd>
</dl>
<dl>
<dt>ADC Noise Reduction Mode (SLEEP_MODE_ADC)</dt>
<dd> In diesem Modus liegt das Hauptaugenmerk darauf, die CPU soweit stillzulegen, dass der ADC möglichst keine Störungen aus dem inneren der CPU auffangen kann. Aufwachen aus diesem Modus kann ausgelöst werden durch den ADC, externe Interrupts, TWI, Timer und Watchdog.
</dd>
</dl>
<dl>
<dt>Power-Down Mode (SLEEP_MODE_PWR_DOWN)</dt>
<dd> In diesem Modus wird ein externer Oszillator (Quarz, Quarzoszillator) gestoppt. Geweckt werden kann die CPU durch einen externen Level Interrupt, TWI, Watchdog, Brown-Out-Reset
</dd>
</dl>
<dl>
<dt>Power-Save-Mode (SLEEP_MODE_PWR_SAVE)</dt>
<dd> Power-Save ist identisch zu Power-Down mit einer Ausnahme: Ist der Timer 2 auf die Verwendung eines externen Taktes konfiguriert, so läuft dieser Timer auch im Power-Save weiter und kann die CPU mit einem Interrupt aufwecken.
</dd>
</dl>
<dl>
<dt>Standby-Mode (SLEEP_MODE_STANDBY, SLEEP_MODE_EXT_STANDBY)</dt>
<dd> Voraussetzung für den Standby-Modus ist die Verwendung eines Quarzes oder eines Quarzoszillators (also einer externen Taktquelle). Ansonsten ist dieser Modus identisch zum Power-Down Modus. Vorteil dieses Modus ist eine kürzere Aufwachzeit.
</dd>
</dl>
<p>Siehe auch:
</p>
<ul>
<li> <a rel="nofollow" class="external text" href="http://www.nongnu.org/avr-libc/user-manual/index.html">Dokumentation der avr-libc</a> Abschnitt Modules/Power Management and Sleep-Modes
</li>
<li> <a class="external text" href="http://www.mikrocontroller.net/topic/96369#832712">Forenbeitrag</a> zur "Nichtverwendung" von sleep_mode in ISRs.
</li>
</ul>
<h1><span class="mw-headline" id="Zeiger">Zeiger</span></h1>
<p>Zeiger (engl. <i>Pointer</i>) sind Variablen, die die Adresse von Daten oder Funktionen enthalten und belegen 16 Bits. Die Größe hängt mit dem adressierbaren Speicherbereich zusammen und der GCC reserviert dann den entsprechenden Platz.
Ggf. ist es also günstiger, Indizes auf Arrays (Listen) zu verwenden, so dass der GCC für die Zeigerarithmetik den erforderlichen RAM nur temporär benötigt.
</p><p>Siehe auch: <a href="http://www.mikrocontroller.net/articles/Zeiger" title="Zeiger">Zeiger</a>
</p>
<h1><span class="mw-headline" id="Speicherzugriffe">Speicherzugriffe</span></h1>
<p>Atmel AVR-Controller verfügen typisch über drei Speicher:
</p>
<ul>
<li> <a href="http://www.mikrocontroller.net/articles/RAM" title="RAM" class="mw-redirect">RAM</a>: Im RAM (genauer statisches RAM/SRAM) wird vom gcc-Compiler Platz für Variablen reserviert. Auch der Stack befindet sich im RAM. Dieser Speicher ist "flüchtig", d.h. der Inhalt der Variablen geht beim Ausschalten oder einem Zusammenbruch der Spannungsversorgung verloren.
</li>
</ul>
<ul>
<li> Programmspeicher: Ausgeführt als FLASH-Speicher, seitenweise wiederbeschreibbar. Darin ist das Anwendungsprogramm abgelegt.
</li>
</ul>
<ul>
<li> <a href="http://www.mikrocontroller.net/articles/EEPROM" title="EEPROM" class="mw-redirect">EEPROM</a>: Nichtflüchtiger Speicher, d.h. der einmal geschriebene Inhalt bleibt auch ohne Stromversorgung erhalten. Byte-weise schreib/lesbar. Im EEPROM werden typischerweise gerätespezifische Werte wie z.&nbsp;B. Kalibrierungswerte von Sensoren abgelegt.
</li>
</ul>
<p>Einige AVRs besitzen keinen RAM-Speicher, lediglich die Register können als "Arbeitsvariablen"
genutzt werden. Da die Anwendung des avr-gcc auf solch "kleinen" Controllern ohnehin selten sinnvoll ist und auch nur bei einigen RAM-losen Typen nach <a rel="nofollow" class="external text" href="http://lightner.net/avr/ATtinyAvrGcc.html">"Bastelarbeiten"</a> möglich ist, werden diese Controller hier nicht weiter berücksichtigt. Auch EEPROM-Speicher ist nicht auf allen Typen verfügbar. Generell sollten die nachfolgenden Erläuterungen auf alle ATmega-Controller und die größeren AT90-Typen übertragbar sein. Für die Typen ATtiny2313, ATtiny26 und viele weitere der "ATtiny-Reihe" gelten die Ausführungen ebenfalls.
</p><p>Siehe auch:
</p>
<ul>
<li> <a href="http://www.mikrocontroller.net/articles/Bin%C3%A4re_Daten_zum_Programm_hinzuf%C3%BCgen" title="Binäre Daten zum Programm hinzufügen">Binäre Daten zum Programm hinzufügen</a>
</li>
</ul>
<h2><span class="mw-headline" id="RAM">RAM</span></h2>
<p>Die Verwaltung des RAM-Speichers erfolgt durch den Compiler, im Regelfall ist beim Zugriff auf Variablen im RAM nichts Besonderes zu beachten. Die Erläuterungen in jedem brauchbaren C-Buch gelten auch für den vom avr-gcc-Compiler erzeugten Code.
</p><p>Um Speicher dynamisch (während der Laufzeit) zu reservieren, kann <b>malloc()</b> verwendet werden. malloc(size) "alloziert" (~reserviert) einen gewissen Speicherblock mit <b>size</b> Bytes. Ist kein Platz für den neuen Block, wird NULL (0) zurückgegeben.
</p><p>Wird der angelegte Block zu klein (groß), kann die Größe mit realloc() verändert werden. Den allozierten Speicherbereich kann man mit free() wieder freigeben. Wenn das Freigeben eines Blocks vergessen wird spricht man von einem "Speicherleck" (memory leak).
</p><p>malloc() legt Speicherblöcke im <b>Heap</b> an, belegt man zuviel Platz, dann wächst der Heap zu weit nach oben und überschreibt den Stack, und der Controller kommt in Teufels Küche. Das kann leider nicht nur passieren wenn man insgesamt zu viel Speicher anfordert, sondern auch wenn man Blöcke unterschiedlicher Größe in ungünstiger Reihenfolge alloziert/freigibt (siehe Artikel <a href="http://www.mikrocontroller.net/articles/Heap-Fragmentierung" title="Heap-Fragmentierung">Heap-Fragmentierung</a>). Aus diesem Grund sollte man malloc() auf Mikrocontrollern sehr sparsam (am besten gar nicht) verwenden.
</p><p>Beispiel zur Verwendung von malloc():
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;stdlib.h&gt;</span>
&nbsp;
<span class="kw4">void</span> foo<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span> <span class="br0">{</span>
  <span class="co1">// neuen speicherbereich anlegen,</span>
  <span class="co1">// platz für 10 uint16</span>
  <span class="kw4">uint16_t</span><span class="sy0">*</span> pBuffer <span class="sy0">=</span> <span class="kw3">malloc</span><span class="br0">(</span><span class="nu0">10</span> <span class="sy0">*</span> <span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">uint16_t</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
  <span class="co1">// darauf zugreifen, als wärs ein gewohnter Buffer</span>
  pBuffer<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
&nbsp;
  <span class="co1">// Speicher (unbedingt!) wieder freigeben</span>
  <span class="kw3">free</span><span class="br0">(</span>pBuffer<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<p>Wenn (wie in obigem Beispiel) dynamischer Speicher nur für die Dauer einer Funktion benötigt und am Ende wieder freigegeben wird, bietet es sich an, statt malloc() <b>alloca()</b> zu verwenden. Der Unterschied zu malloc() ist, dass der Speicher auf dem Stack reserviert wird, und beim Verlassen der Funktion automatisch wieder freigegeben wird. Es kann somit kein Speicherleck und keine Fragmentierung entstehen.
</p><p>siehe auch:
</p>
<ul>
<li> <a rel="nofollow" class="external free" href="http://www.nongnu.org/avr-libc/user-manual/malloc.html">http://www.nongnu.org/avr-libc/user-manual/malloc.html</a>
</li>
</ul>
<h2><span class="mw-headline" id="Flash_mit_PROGMEM_und_pgm_read">Flash mit PROGMEM und pgm_read</span></h2>
<p>→ <a rel="nofollow" class="external text" href="http://nongnu.org/avr-libc/user-manual/group__avr__pgmspace.html">avr-libc: Doku zu avr/pgmspace.h</a>
</p><p>Ein Zugriff auf Konstanten im Programmspeicher ist mittels avr-gcc erst ab Version 4.7 "transparent" möglich. Um Daten aus dem Flash zu lesen, muss die AVR-Instruktion LPM (<i>Load from Program Memory</i>) erzeugt werden, bei Controllern mit mehr als 64kiB Flash auch ELMP.
</p><p>Dazu gibt es das AVR-spezifische GCC-Attribut <tt>progmem</tt>, mit dem eine Variablendeklaration im <i>static storage</i><sup id="cite_ref-5" class="reference"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#cite_note-5">[5]</a></sup> markiert werden kann:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">const</span> <span class="kw4">int</span> value __attribute__<span class="br0">(</span><span class="br0">(</span>progmem<span class="br0">)</span><span class="br0">)</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span></pre></div></div>
<p>Effekt ist, dass die so markierte Variable nicht im RAM sondern im Flash angelegt wird.  Wird durch "normalen" C-Code auf solch eine Variable zugegriffen, wird jedoch aus dem RAM gelesen und nicht aus dem Flash!
</p><p>Zum Lesen aus dem Flash stellt die avr-libc daher zahlreiche Makros zur Verfügung.  Zudem wird das Makro <tt>PROGMEM</tt> definiert, das etwas Tipparbeit spart:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/pgmspace.h&gt;</span>
&nbsp;
<span class="kw4">const</span> <span class="kw4">int</span> value PROGMEM <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span></pre></div></div>
<p><tt>progmem</tt> funktioniert im Wesentlichen wie ein Section-Attribut, das die Daten in der Section <tt>.progmem.data</tt> ablegt.  Im Gegensatz zum Section-Attribut werden jedoch noch weitere Prüfungen unternommen, ab avr-gcc 4.6 etwa muss die entsprechende Variable <tt>const</tt> sein.
</p>
<h3><span class="mw-headline" id="Integer_und_float">Integer und float</span></h3>
<p>Zum Lesen von Skalaren stellt die avr-libc folgende Makros zu Verfügung, die jeweils ein Argument erhalten: Die 16-Bit Adresse des zu lesenden Wertes<sup id="cite_ref-6" class="reference"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#cite_note-6">[6]</a></sup>
</p>
<dl><dd><table border="1" cellpadding="4" style="margin: 1em 1em 1em 0; background: #f9f9f9; border: 1px #AAA solid; border-collapse: collapse; empty-cells:show; {{{1}}} }">
<caption> Übersicht der <tt>pgm_read</tt> Funktionen aus<br>dem Header <tt>avr/pgmspace.h</tt> der avr-libc
</caption>
<tbody><tr>
<th> Gelesener Wert </th>
<th> <tt>pgm_read_xxx</tt> </th>
<th> Anzahl Bytes
</th></tr>
<tr>
<td> <tt>uint8_t</tt> </td>
<td> <tt>pgm_read_byte</tt> </td>
<td> 1
</td></tr>
<tr>
<td> <tt>uint16_t</tt> </td>
<td> <tt>pgm_read_word</tt> </td>
<td> 2
</td></tr>
<tr>
<td> <tt>uint32_t</tt> </td>
<td> <tt>pgm_read_dword</tt> </td>
<td> 4
</td></tr>
<tr>
<td> <tt>float</tt> </td>
<td> <tt>pgm_read_float</tt><sup id="cite_ref-7" class="reference"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#cite_note-7">[7]</a></sup> </td>
<td> 4
</td></tr></tbody></table></dd></dl>
<p>Soll ein Zeiger gelesen werden, so verwendet man <tt>pgm_read_word</tt> und castet das Ergebnis zum gewünschten Zeiger-Typ.
</p>
<dl>
<dt>Beispiele</dt>
<dd>
</dd>
</dl>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/pgmspace.h&gt;</span>
&nbsp;
<span class="coMULTI">/* Byte */</span>
<span class="kw4">const</span> <span class="kw4">uint8_t</span> aByte PROGMEM <span class="sy0">=</span> <span class="nu0">123</span><span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* int-Array */</span>
<span class="kw4">const</span> <span class="kw4">int</span> anArray<span class="br0">[</span><span class="br0">]</span> PROGMEM <span class="sy0">=</span> <span class="br0">{</span> <span class="nu0">18</span><span class="sy0">,</span> <span class="nu0">3</span> <span class="sy0">,</span><span class="nu0">70</span> <span class="br0">}</span><span class="sy0">;</span>
&nbsp;
<span class="kw4">void</span> foo <span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span>
<span class="br0">{</span>
  <span class="coMULTI">/* Zeiger */</span>
  <span class="kw4">static</span> <span class="kw4">const</span> <span class="kw4">uint8_t</span><span class="sy0">*</span> <span class="kw4">const</span> aPointer PROGMEM <span class="sy0">=</span> <span class="sy0">&amp;</span>aByte<span class="sy0">;</span>
&nbsp;
  <span class="kw4">uint8_t</span> a        <span class="sy0">=</span> pgm_read_byte <span class="br0">(</span><span class="sy0">&amp;</span>aByte<span class="br0">)</span><span class="sy0">;</span>
  <span class="kw4">int</span> a2           <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> pgm_read_word <span class="br0">(</span><span class="sy0">&amp;</span>anArray<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw4">const</span> <span class="kw4">uint8_t</span><span class="sy0">*</span> p <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">const</span> <span class="kw4">uint8_t</span><span class="sy0">*</span><span class="br0">)</span> pgm_read_word <span class="br0">(</span><span class="sy0">&amp;</span>aPointer<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<h3><span class="mw-headline" id="Bl.C3.B6cke">Blöcke</span></h3>
<p>In den Flash-Funktionen der avr-libc sind keine der pgm_read_xxxx Nomenklatur folgenden Funktionen, die Speicherblöcke auslesen oder vergleichen. Die enstprechende Funktionen sind Varianten von <tt>memcpy</tt>, <tt>memcmp</tt> und heißt <tt>memcpy_P</tt>, <tt>memcmp_P</tt>, usw.  Für weitere Funktionen und deren Prototypen siehe die Dokumentation der avr-libc.
</p>
<h3><span class="mw-headline" id="Strings">Strings</span></h3>
<p>Strings sind in C nichts anderes als eine Abfolge von Zeichen und einem <tt>'\0'</tt> als Stringende. Der prinzipielle Weg ist daher identisch zum  Lesen von Bytes, wobei auf die <a href="http://www.mikrocontroller.net/articles/FAQ#Wie_funktioniert_String-Verarbeitung_in_C.3F" title="FAQ">Besonderheiten von Strings</a> wie 0-Terminierung geachtet werden muss.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/pgmspace.h&gt;</span>
&nbsp;
<span class="kw4">size_t</span> my_string_length <span class="br0">(</span><span class="kw4">const</span> <span class="kw4">char</span><span class="sy0">*</span> addr<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">size_t</span> length <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
&nbsp;
    <span class="kw1">while</span> <span class="br0">(</span>pgm_read_byte <span class="br0">(</span>addr<span class="sy0">++</span><span class="br0">)</span><span class="br0">)</span>
    <span class="br0">{</span>
        len<span class="sy0">++;</span>
    <span class="br0">}</span>
    <span class="kw1">return</span> length<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<p>Zur Unterstützung des Programmierers steht das Repertoire der str-Funktionen auch in jeweils eine Variante zur Verfügung, die mit dem Flash-Speicher arbeiten kann. Die Funktionsnamen tragen den Suffix <tt>_P</tt>. Darüber hinaus gibt es das Makro <tt>PSTR</tt>, das ein String-Literal im Flash-Speicher ablegt und die Adresse des Strings liefert:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/pgmspace.h&gt;</span>
&nbsp;
<span class="coMULTI">/* Liefert true zurück, wenn string_im_ram gleich "Hallo Welt" ist. */</span>
<span class="kw4">int</span> foo <span class="br0">(</span><span class="kw4">const</span> <span class="kw4">char</span><span class="sy0">*</span> string_im_ram<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">return</span> strcmp_P <span class="br0">(</span>string_im_ram<span class="sy0">,</span> PSTR <span class="br0">(</span><span class="st0">"Hallo Welt"</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<p>Zu beachten ist, dass <tt>PSTR</tt> nur innerhalb von Funktionen verwendet werden kann.
</p>
<dl>
<dt> Array aus Strings</dt>
<dd>
</dd>
</dl>
<p>Arrays aus Strings im Flash-Speicher werden in zwei Schritten angelegt:
</p>
<ol>
<li> Zuerst die einzelnen Elemente des Arrays und
</li>
<li> im Anschluss ein Array, in dem die Startaddressen der Strings abgelegt werden.
</li>
</ol>
<p>Zum Auslesen wird zuerst die Adresse des gewünschten Elements aus dem Array im Flash-Speicher gelesen, die im Anschluss dazu genutzt wird, um auf das Element (den String) selbst zuzugreifen.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/pgmspace.h&gt;</span>
&nbsp;
<span class="kw4">static</span> <span class="kw4">const</span> <span class="kw4">char</span> str1<span class="br0">[</span><span class="br0">]</span> PROGMEM <span class="sy0">=</span> <span class="st0">"Hund"</span><span class="sy0">;</span>
<span class="kw4">static</span> <span class="kw4">const</span> <span class="kw4">char</span> str2<span class="br0">[</span><span class="br0">]</span> PROGMEM <span class="sy0">=</span> <span class="st0">"Katze"</span><span class="sy0">;</span>
<span class="kw4">static</span> <span class="kw4">const</span> <span class="kw4">char</span> str3<span class="br0">[</span><span class="br0">]</span> PROGMEM <span class="sy0">=</span> <span class="st0">"Maus"</span><span class="sy0">;</span>
&nbsp;
<span class="kw4">const</span> <span class="kw4">char</span> <span class="sy0">*</span> <span class="kw4">const</span> array<span class="br0">[</span><span class="br0">]</span> PROGMEM <span class="sy0">=</span> 
<span class="br0">{</span>
   str1<span class="sy0">,</span> str2<span class="sy0">,</span> str3
<span class="br0">}</span><span class="sy0">;</span>
&nbsp;
<span class="co1">// Liest den i-ten String von array[] und kopiert ihn ins RAM nach buf[]</span>
<span class="kw4">void</span> read_string <span class="br0">(</span><span class="kw4">char</span><span class="sy0">*</span> buf<span class="sy0">,</span> <span class="kw4">size_t</span> i<span class="br0">)</span>
<span class="br0">{</span>
    <span class="co1">// Lese die Adresse des i-ten Strings aus array[]</span>
    <span class="kw4">const</span> <span class="kw4">char</span> <span class="sy0">*</span>parray <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">const</span> <span class="kw4">char</span><span class="sy0">*</span><span class="br0">)</span> pgm_read_word <span class="br0">(</span><span class="sy0">&amp;</span>array<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// Kopiere den Inhalt der Zeichenkette vom Flash ins RAM</span>
    strcpy_P <span class="br0">(</span>buf<span class="sy0">,</span> parray<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<p>Eine weitere Möglichkeit ist, die Strings in einem 2-dimensionalen char-Array abzulegen anstatt deren Adresse in einem 1-dimensionalen Adress-Array zu speichern.
</p><p>Vorteil ist, dass der Code einfacher wird.  Nachteil ist, dass bei unterschiedlich langen Strings Speicherplatz verschwendet wird, weil sich die Array-Dimension and der Länge des längsten Strings orientieret.  Bei in etwa gleich langen Strings kann es aber sogar Speicherplatz sparen, denn es die Adressen der einzelnen Strings müssen nicht abgespeichert werden.<sup id="cite_ref-8" class="reference"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#cite_note-8">[8]</a></sup>
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/pgmspace.h&gt;</span>
&nbsp;
<span class="co1">// Die "6" ist 1 plus die Länge des längsten Strings ("Katze")</span>
<span class="kw4">const</span> <span class="kw4">char</span> array<span class="br0">[</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">6</span><span class="br0">]</span> PROGMEM <span class="sy0">=</span> 
<span class="br0">{</span>
   <span class="st0">"Hund"</span><span class="sy0">,</span> <span class="st0">"Katze"</span><span class="sy0">,</span> <span class="st0">"Maus"</span>
<span class="br0">}</span><span class="sy0">;</span>
&nbsp;
<span class="co1">// Liest den i-ten String von array[] und kopiert ihn ins RAM nach buf[]</span>
<span class="kw4">void</span> read_string <span class="br0">(</span><span class="kw4">char</span><span class="sy0">*</span> buf<span class="sy0">,</span> <span class="kw4">size_t</span> i<span class="br0">)</span>
<span class="br0">{</span>
    <span class="co1">// Kopiere den Inhalt der i-ten Zeichenkette vom Flash ins RAM</span>
    strcpy_P <span class="br0">(</span>buf<span class="sy0">,</span> array<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<p>Siehe dazu auch die avr-libc FAQ: <a rel="nofollow" class="external text" href="http://www.nongnu.org/avr-libc/user-manual/FAQ.html#faq_rom_array">How do I put an array of strings completely in ROM?</a>
</p>
<h3><span class="mw-headline" id="Warum_so_kompliziert.3F">Warum so kompliziert?</span></h3>
<p>Zu dem Thema, warum die Verabeitung von Werten aus dem Flash-Speicher so kompliziert ist, sei hier nur kurz erläutert: Die Harvard-Architektur des AVR weist getrennte Adressräume für Programm (Flash) und Datenspeicher (RAM) auf. Der C-Standard sieht keine unterschiedlichen Adressräume vor.
</p><p>Hat man zum Beispiel eine Funktion string_an_uart (const char* s) und übergibt an diese Funktion die Adresse einer Zeichenkette, dann weiß die Funktion nicht, ob die Adresse in den Flash-Speicher oder das RAM zeigt. Weder aus dem Pointer-Wert, also dem Zahlenwert, noch aus dem "const" kann auf den Ort der Ablage geschlossen werden.
</p><p>Einige AVR-Compiler bilden die Harvard-Architektur ab, indem sie in einen Pointer nicht nur die Adresse speichern, sondern auch den Ablageort wie <i>Flash</i> oder <i>RAM</i>. In einem Aufruf einer Funktion wird dann bei Pointer-Parametern neben der Adresse auch der Speicherbereich, auf den der Pointer zeigt, übergeben.
</p><p>Dies hat jedoch auch Nachteile, denn bei jedem Zugriff über einen Zeiger muss zur <i>Laufzeit</i> entschieden werden, wie der Zugriff auszuführen ist und entsprechend länglicher und langsamer wird der erzeugte Code.
</p><p>Siehe auch:
</p>
<ul>
<li> <a rel="nofollow" class="external text" href="http://www.nongnu.org/avr-libc/user-manual/index.html">Dokumentation der avr-libc</a> Abschnitte Modules/Program Space String Utilities und Abschnitt Modules/Bootloader Support Utilities
</li>
</ul>
<h3><span class="mw-headline" id="Variablenzugriff_.3E64kB">Variablenzugriff &gt;64kB</span></h3>
<p>Die Zeiger beim avr-gcc sind nur 16 Bit breit, können somit also nur 64kiB Datenspeicher adressieren. Als Funktionspointer können sie beim AVR bis zu 128 kiB Programmspeicher adressieren, weil FUnktionsadressen immer gerade sind. Für den Datenzugriff jenseits von 64kiB stellt die AVR-Libc die Funktionen <tt>pgm_read_xxx_far</tt> zur Verfügung. Diese Funktionen erwarten einen 32-Bit Pointer auf die Daten. Unverständlicherweise gibt es aber in der AVR-Libc keine Funktion, um diesen 32-Bit Pointer zu erhalten. Hier schafft ein eigenes Makro Abhilfe:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/io.h&gt;</span>
<span class="co2">#include &lt;avr/pgmspace.h&gt;</span>
&nbsp;
<span class="co1">//====================================================================</span>
<span class="co1">// Macro to access strings defined in PROGMEM above 64kB</span>
<span class="co1">//--------------------------------------------------------------------</span>
<span class="co2">#define FAR(var)                     \
({ uint_farptr_t tmp;                \
   __asm__ (                         \
       "ldi   &nbsp;%A0, lo8(%1)"  "\n\t" \
       "ldi   &nbsp;%B0, hi8(%1)"  "\n\t" \
       "ldi   &nbsp;%C0, hh8(%1)"         \
      &nbsp;: "=d" (tmp)                  \
      &nbsp;: "i"  (&amp;(var)));             \
   tmp;                              \
})</span>
<span class="co1">//-------------------------------------------------------------------</span>
&nbsp;
<span class="co1">//===================================================================</span>
<span class="co1">// Define a section above 64kiB (FAR_SECTION)</span>
<span class="co1">// and add the required linker argument below</span>
<span class="co1">// -Wl,--section-start=.far_section=0x10000</span>
<span class="co1">//--------------------------------------------------------------------</span>
<span class="co2">#define FAR_SECTION   __attribute__((__section__(".far_section")))</span>
<span class="co1">//--------------------------------------------------------------------</span>
&nbsp;
<span class="co1">//====================================================================</span>
<span class="co1">// Just a Sample</span>
<span class="co1">//--------------------------------------------------------------------</span>
&nbsp;
<span class="kw4">char</span> MyString<span class="br0">[</span><span class="br0">]</span> FAR_SECTION <span class="sy0">=</span> <span class="st0">"Hier liegt mein FAR-Teststring!"</span><span class="sy0">;</span>
<span class="kw4">char</span> MyBmp64<span class="br0">[</span><span class="br0">]</span>  FAR_SECTION <span class="sy0">=</span> <span class="br0">{</span><span class="nu12">0xAA</span><span class="sy0">,</span><span class="nu12">0xBB</span><span class="sy0">,</span><span class="nu12">0xCC</span><span class="sy0">,</span><span class="nu12">0xDD</span><span class="sy0">,</span><span class="nu12">0xEE</span><span class="sy0">,</span><span class="nu12">0xFF</span><span class="sy0">,</span><span class="nu12">0x00</span><span class="br0">}</span><span class="sy0">;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw4">char</span> MyChar<span class="sy0">;</span>
  DDRC <span class="sy0">=</span> <span class="nu12">0xFF</span><span class="sy0">;</span>
  <span class="kw1">do</span>
  <span class="br0">{</span>
    MyChar <span class="sy0">=</span> pgm_read_byte_far<span class="br0">(</span>FAR<span class="br0">(</span>MyBmp64<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    PORTC  <span class="sy0">=</span> MyChar<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw1">while</span><span class="br0">(</span>MyChar<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<p>D.h. man muss
</p>
<ul>
<li> Das Makro FAR im Quellcode einfügen
</li>
<li> Die Definition der neuen Sektion FAR_SECTION einfügen
</li>
<li> Die Variablen mit dieser Sektion kennzeichnen
</li>
<li> Dem Linker mittels Kommandozeilenoption diese Sektion mitteilen
</li>
</ul>
<p>Der Zugriff auf diese Variablen kann nur mittels direkter Pointerarithmetik erfolgen, eine Indizierung von Arrays mit variablem Index ist nicht möglich.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> n<span class="sy0">=</span><span class="nu0">3</span><span class="sy0">;</span>
MyChar <span class="sy0">=</span> pgm_read_byte_far<span class="br0">(</span>FAR<span class="br0">(</span>MyBmp64<span class="br0">)</span><span class="sy0">+</span>n<span class="br0">)</span><span class="sy0">;</span></pre></div></div>
<h2><span class="mw-headline" id="Flash_mit_flash_und_Embedded-C">Flash mit __flash und Embedded-C</span></h2>
<p>Ab Version 4.7 unterstützt avr-gcc <i>Adress-Spaces</i> gemäß dem Embedded-C Dokument ISO/IEC TR18037.  Der geläufigste Adress-Space ist <tt>__flash</tt>, der im Gegensatz zu <tt>progmem</tt> kein GCC-Attribut ist, sondern ein Qualifier und damit syntaktisch ähnlich verwendet wird wie <tt>const</tt> oder <tt>volatile</tt>.
</p><p>GCC kennt keine eigene Option zum Aktivieren von Embedded-C, es wird als GNU-C Erweiterung behandelt. Daher müssen C-Module, die Address-Spaces verwenden, mit <tt>-std=gnu99</tt> o.ä. compiliert werden.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">static</span> <span class="kw4">const</span> __flash <span class="kw4">int</span> value <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">;</span>
&nbsp;
<span class="kw4">int</span> get_value <span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw1">return</span> value<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<ol>
<li> Im Gegensatz zu <tt>progmem</tt> sind keine speziellen Bibliotheksfunktionen oder -makros für den Zugriff mehr notwendig: Der Code zum Lesen der Variable ist "normales" C.
</li>
<li> Die Variable wird im richtigen Speicherbereich (Flash) angelegt.
</li>
<li> <tt>__flash</tt> ist nur zusammen mit read-only Objekten oder Zeigern, d.h. nur zusammen mit <tt>const</tt>, erlaubt.
</li>
<li> Zugriffe wie im obigen Beispiel können (weg)optimiert werden.  Das Beispiel entspricht einem "<tt>return 10</tt>".  Es besteht keine Notwendigkeit, für <tt>value</tt> überhaupt Flash-Speicher zu reservieren.
</li>
</ol>
<p>Auch Zeiger-Indirektionen sind problemlos möglich.  Zu beachten ist, dass <tt>__flash</tt> auf der richtigen Seite des "<tt>*</tt>" in der Zeigerdeklaration bzw. -definition steht:
</p>
<ul>
<li> <b>Rechts vom <tt>*</tt>:</b> Der Zeiger selbst liegt im Flash
</li>
<li> <b>Links vom <tt>*</tt>:</b> Der Zeiger enthält eine Flash-Adresse
</li>
</ul>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co1">// val ist eine Variable im Flash</span>
<span class="kw4">const</span> __flash <span class="kw4">int</span> val <span class="sy0">=</span> <span class="nu0">42</span><span class="sy0">;</span>
&nbsp;
<span class="co1">// pval liegt auch im Flash und enthält die Adresse von val</span>
<span class="kw4">const</span> __flash <span class="kw4">int</span><span class="sy0">*</span> <span class="kw4">const</span> __flash pval <span class="sy0">=</span> <span class="sy0">&amp;</span>val<span class="sy0">;</span>
&nbsp;
<span class="kw4">char</span> get_val <span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span>
<span class="br0">{</span>
  <span class="co1">// liest den Wert von val über die in pval abgelegte Adresse</span>
  <span class="kw1">return</span> <span class="sy0">*</span>pval<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<h3><span class="mw-headline" id="Bl.C3.B6cke_2">Blöcke</span></h3>
<p>Um Speicherbereiche vom Flash in den RAM zu kopieren, gibt es zwei Möglichkeiten: Zum einen können wie bei <tt>progmem</tt> beschreiben die Funktionen der avr-libc wie <tt>memcpy_P</tt>, <tt>memcmp_P</tt>, <tt>movmem_P</tt>, etc. verwendet werden:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/pgmspace.h&gt;</span>
&nbsp;
<span class="co1">// Eine Datenstruktur</span>
<span class="kw4">typedef</span> <span class="kw4">struct</span>
<span class="br0">{</span>
    <span class="kw4">int</span> id<span class="sy0">;</span>
    <span class="kw4">char</span> buf<span class="br0">[</span><span class="nu0">10</span><span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span> data_t<span class="sy0">;</span>
&nbsp;
<span class="kw2">extern</span> <span class="kw4">void</span> uart_send <span class="br0">(</span><span class="kw4">const</span> <span class="kw4">void</span><span class="sy0">*,</span> <span class="kw4">size_t</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
<span class="kw4">void</span> send_data <span class="br0">(</span><span class="kw4">const</span> __flash data_t <span class="sy0">*</span>pdata<span class="br0">)</span>
<span class="br0">{</span>
    <span class="co1">// buf wird auf dem Stack angelegt</span>
    data_t buf<span class="sy0">;</span>
&nbsp;
    <span class="co1">// Kopiere Daten vom Flash nach buf ins RAM</span>
    memcpy_P <span class="br0">(</span><span class="sy0">&amp;</span>buf<span class="sy0">,</span> pdata<span class="sy0">,</span> <span class="kw4">sizeof</span> <span class="br0">(</span>data_t<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// Sende die Daten in buf</span>
    uart_send <span class="br0">(</span><span class="sy0">&amp;</span>buf<span class="sy0">,</span> <span class="kw4">sizeof</span> <span class="br0">(</span>data_t<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<p>Zum anderen kann eine Struktur auch über direktes Kopieren ins RAM geladen werden:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;stdlib.h&gt;</span>
&nbsp;
<span class="co1">// Eine Datenstruktur</span>
<span class="kw4">typedef</span> <span class="kw4">struct</span>
<span class="br0">{</span>
    <span class="kw4">int</span> id<span class="sy0">;</span>
    <span class="kw4">char</span> buf<span class="br0">[</span><span class="nu0">10</span><span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span> data_t<span class="sy0">;</span>
&nbsp;
<span class="kw2">extern</span> <span class="kw4">void</span> uart_send <span class="br0">(</span><span class="kw4">const</span> <span class="kw4">void</span><span class="sy0">*,</span> <span class="kw4">size_t</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
<span class="kw4">void</span> send_data <span class="br0">(</span><span class="kw4">const</span> __flash data_t <span class="sy0">*</span>pdata<span class="br0">)</span>
<span class="br0">{</span>
    <span class="co1">// Kopiere Daten ins RAM.  buf wird auf dem Stack angelegt</span>
    <span class="kw4">const</span> data_t buf <span class="sy0">=</span> <span class="sy0">*</span>pdata<span class="sy0">;</span>
&nbsp;
    <span class="co1">// Verwendet die Daten in buf</span>
    uart_send <span class="br0">(</span><span class="sy0">&amp;</span>buf<span class="sy0">,</span> <span class="kw4">sizeof</span> <span class="br0">(</span>data_t<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<h3><span class="mw-headline" id="Strings_2">Strings</span></h3>
<p>Natürlich können auch Strings im Flash abgelegt werden und auch mit Funktionen wie <tt>strcpy_P</tt> aus der avr-libc verarbeitet werden.  Zudem ist es möglich, Flash-Zeiger mit der Adresse eines String-Literals zu initialisieren:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/pgmspace.h&gt;</span>
&nbsp;
<span class="co2">#define FSTR(X) ((const __flash char[]) { X } )</span>
&nbsp;
<span class="kw4">const</span> __flash <span class="kw4">char</span> <span class="sy0">*</span> <span class="kw4">const</span> __flash array<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> 
<span class="br0">{</span>
    FSTR <span class="br0">(</span><span class="st0">"Hund"</span><span class="br0">)</span><span class="sy0">,</span> FSTR <span class="br0">(</span><span class="st0">"Katze"</span><span class="br0">)</span><span class="sy0">,</span> FSTR <span class="br0">(</span><span class="st0">"Maus"</span><span class="br0">)</span>
<span class="br0">}</span><span class="sy0">;</span>
&nbsp;
<span class="kw4">size_t</span> get_len <span class="br0">(</span><span class="kw4">uint8_t</span> tier<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">return</span> strlen_P <span class="br0">(</span>array<span class="br0">[</span>tier<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<p>Leider sieht der Embedded-C Draft nicht vor, String-Literale direkt in einem anderen Adress-Space als <i>generic</i> anzulegen, so dass hier der Umweg über <tt>FSTR</tt> genommen werden muss.  Dieses Konstrukt ist nur ausserhalb von Funktionen möglich und kann daher nicht als Ersatz für <tt>PSTR</tt> aus der avr-libc dienen.
</p><p>Soll <tt>array</tt> ein 2-dimensonales Array sein anstatt ein 1-dimensionales Array von Zeigern, dann geht das ohne große Verrenkungen:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co1">// Die 6 ergibt sich aus 1 plus der Länge des längsten Strings "Katze"</span>
<span class="kw4">const</span> __flash <span class="kw4">char</span> array<span class="br0">[</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">6</span><span class="br0">]</span> <span class="sy0">=</span> 
<span class="br0">{</span>
    <span class="st0">"Hund"</span><span class="sy0">,</span> <span class="st0">"Katze"</span><span class="sy0">,</span> <span class="st0">"Maus"</span>
<span class="br0">}</span><span class="sy0">;</span></pre></div></div>
<p>Weiters besteht die Möglichkeit, <tt>array</tt> analog anzulegen, wie man es mit <tt>PROGMEM</tt> machen würde:  Jeder String wird explizit angelegt und seine Adresse bei der Initialisierung von <tt>array</tt> verwendet.  Dies entspricht dem ersten Beispiel eines 1-dimensionalen Zeigerarrays:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">static</span> <span class="kw4">const</span> __flash <span class="kw4">char</span> strHund<span class="br0">[</span><span class="br0">]</span>  <span class="sy0">=</span> <span class="st0">"Hund"</span><span class="sy0">;</span>
<span class="kw4">static</span> <span class="kw4">const</span> __flash <span class="kw4">char</span> strKatze<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"Katze"</span><span class="sy0">;</span>
<span class="kw4">static</span> <span class="kw4">const</span> __flash <span class="kw4">char</span> strMaus<span class="br0">[</span><span class="br0">]</span>  <span class="sy0">=</span> <span class="st0">"Maus"</span><span class="sy0">;</span>
&nbsp;
<span class="kw4">const</span> __flash <span class="kw4">char</span> <span class="sy0">*</span> <span class="kw4">const</span> __flash array<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> 
<span class="br0">{</span>
    strHund<span class="sy0">,</span> strKatze<span class="sy0">,</span> strMaus
<span class="br0">}</span><span class="sy0">;</span></pre></div></div>
<h3><span class="mw-headline" id="Casts">Casts</span></h3>
<p>Embedded C fordert, dass zwei Adress-Spaces entweder disjunkt sind – d.h. sie enthalten keine gemeinsamen Adressen – oder aber ein Space komplett im anderen enthalten ist, also eine Teilmengen-Beziehung besteht.  Die Adress-Spaces von avr-gcc sind so implementiert, dass jeder Space Teilmenge jedes anderes ist.  Zwar haben Spaces wie RAM und Flash physikalisch keinen Speicherbereich gemein, allerdings ermöglicht diese Implementierung das Casten von Zeigern zu unterschiedlichen Adress-Spaces<sup id="cite_ref-9" class="reference"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#cite_note-9">[9]</a></sup>:  
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;stdbool.h&gt;</span>
&nbsp;
<span class="kw4">char</span> read_char <span class="br0">(</span><span class="kw4">const</span> <span class="kw4">char</span> <span class="sy0">*</span>address<span class="sy0">,</span> bool data_in_flash<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">if</span> <span class="br0">(</span>data_in_flash<span class="br0">)</span>
        <span class="kw1">return</span> <span class="sy0">*</span><span class="br0">(</span><span class="kw4">const</span> __flash <span class="kw4">char</span><span class="sy0">*</span><span class="br0">)</span> address<span class="sy0">;</span>
    <span class="kw1">else</span>
        <span class="kw1">return</span> <span class="sy0">*</span>address<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<p>Der Cast selbst erzeugt keinen zusätzlichen Code, da eine RAM-Adresse und eine Flash-Adresse die gleiche Binärdarstellung haben.  Allerdings wird über den nach <tt>__flash</tt> gecasteten Zeiger anders zugegriffen, nämlich per LPM.
</p>
<h3><span class="mw-headline" id="Jenseits_von_flash">Jenseits von __flash</span></h3>
<p>Ausser <tt>__flash</tt> gibt es auch folgende Address-Spaces:
</p>
<ul>
<li> <tt>__flash</tt><i>N</i>, <i>N</i> = 1..5, sind fünf weitere Spaces, die analog zu <tt>__flash</tt> funktionieren und deren Zeiger ebenfalls 16 Bit breit sind.  avr-gcc erwartet, dass die zugehörigen Daten, welche in die Section <tt>.progmem</tt><i>N</i><tt>.data</tt> abgelegt werden, so lokatiert sind, dass das high-Byte der Adresse (Bits 16..23) gerade <i>N</i> ist.  Dies wird in Binutils noch nicht unterstützt<sup id="cite_ref-10" class="reference"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#cite_note-10">[10]</a></sup> (Stand Binutils 2.24) Die Unterstützung kann durch ein eigenes Linker-Skript erreicht werden, welches diese Sections wie vom Compiler erwartet lokatiert.
</li>
<li> Address-Space <tt>__memx</tt> implementiert 3-Byte Zeiger und unterstützt Lesen über 64KiB-Segmentgrenzen hinweg.  Das MSB (Bit 23) gibt dabei an, ob der Zeiger eine Flash-Adresse enthält (Bit23 = 0) oder eine RAM-Adresse (Bit23 = 1), was folgenden Code erlaubt:
</li>
</ul>
<dl><dd><table>

<tbody><tr>
<td><div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">const</span> __memx <span class="kw4">int</span> a_flash <span class="sy0">=</span> <span class="nu0">42</span><span class="sy0">;</span>
<span class="kw4">const</span>        <span class="kw4">int</span> a_ram   <span class="sy0">=</span> <span class="nu0">100</span><span class="sy0">;</span>
&nbsp;
<span class="kw4">static</span> <span class="kw4">int</span> get_a <span class="br0">(</span><span class="kw4">const</span> __memx <span class="kw4">int</span><span class="sy0">*</span> pa<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">return</span> <span class="sy0">*</span>pa<span class="sy0">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">int</span> main <span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">return</span> get_a <span class="br0">(</span><span class="sy0">&amp;</span>a_flash<span class="br0">)</span> <span class="sy0">+</span> get_a <span class="br0">(</span><span class="sy0">&amp;</span>a_ram<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
</td></tr></tbody></table>Dies bedeutet, dass erst zur <i>Laufzeit</i> entschieden werden kann, ob aus dem RAM oder aus dem Flash gelesen werden soll, was <tt>__memx</tt> im Vergleich zu den anderen Address-Spaces langsamer macht. Ausserdem ist zu beachten, dass <tt>__memx</tt>-Zeiger zwar 24-Bit Zeiger sind, die zugrundeliegende Adress-Arithmetik jedoch gemäß dem C-Standard erfolgt, also als 16-Bit Arithmetik.</dd></dl>
<h3><span class="mw-headline" id="flash.2C_progmem_und_Portierbarkeit">__flash, progmem und Portierbarkeit</span></h3>
<p>Da ab er aktuellen Compilerversion 4.7 sowohl <tt>__flash</tt> als auch <tt>PROGMEM</tt> und die <tt>pgm_read</tt>-Funktionen zur Verfügung stehen, ergibt sich die Frage, welche Variante "besser" ist und wie zwischen ihnen hin- und her zu portieren ist.
</p><p>Zunächst sei erwähnt, dass <tt>__flash</tt> kein Ersatz für <tt>PROGMEM</tt> ist, sondern lediglich eine Alternative dazu.  Das "alte" progmem wird weiterhin mir gleicher Semantik unterstützt, so dass alter Code ohne Änderungen mit den neueren Compilerversionen übersetzbar bleibt.
</p><p>Von der Codegüte her dürften sich keine großen Unterschiede ergeben.  Es ist nicht zu erwarten, dass die eine oder die andere Variante wesentlich besseren oder schlechteren Code erzeugt — von einer Ausnahme abgesehen:  Der Wert beim Zugriff ist zur Compilezeit bekannt und kann daher eliminiert werden.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">static</span> <span class="kw4">const</span> __flash <span class="kw4">char</span> x<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span> <span class="st0">'A'</span><span class="sy0">,</span> <span class="st0">'V'</span><span class="sy0">,</span> <span class="st0">'R'</span> <span class="br0">}</span><span class="sy0">;</span>
&nbsp;
<span class="kw4">char</span> foo <span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">return</span> x<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<p>Dies wird übersetzt wie "<tt>return 'R';</tt>", und das Array <tt>x[]</tt> kann komplett wegoptimiert werden und entfallen.
</p>
<h4><span class="mw-headline" id="progmem_.E2.86.92_flash">progmem → __flash</span></h4>
<p>Portierung in diese Richtung bedeutet, alten Code anzupassen.  Zwingend ist die Portierung nicht, da <tt>progmem</tt> weiterhin unterstützt wird.
Allerdings ist eine Quelle mit <tt>__flash</tt> besser lesbar, denn der Code wird von den <tt>pgm_read</tt>-Funktionen befreit, die vor allem bei Mehrfach-Indirektion den Code ziemlich verunstalten und unleserlich machen können.
Weiterer Vorteil von <tt>_flash</tt> ist, daß eine striktere Typprüfung erfolgen kann.
</p><p>Eine Portierung wird man in zwei Schritten vornehmen:
</p>
<dl>
<dt>1. Definitionen von Flash-Variablen werden angepasst</dt>
<dd>
</dd>
</dl>
<p>Vorher:
</p>
<dl><dd><table>

<tbody><tr>
<td><div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/pgmspace.h&gt;</span>
&nbsp;
<span class="kw4">static</span> <span class="kw4">const</span> <span class="kw4">char</span> hund<span class="br0">[</span><span class="br0">]</span>  PROGMEM <span class="sy0">=</span> <span class="st0">"Hund"</span><span class="sy0">;</span>
<span class="kw4">static</span> <span class="kw4">const</span> <span class="kw4">char</span> katze<span class="br0">[</span><span class="br0">]</span> PROGMEM <span class="sy0">=</span> <span class="st0">"Katze"</span><span class="sy0">;</span>
<span class="kw4">static</span> <span class="kw4">const</span> <span class="kw4">char</span> maus<span class="br0">[</span><span class="br0">]</span>  PROGMEM <span class="sy0">=</span> <span class="st0">"Maus"</span><span class="sy0">;</span>
&nbsp;
<span class="kw4">const</span> <span class="kw4">char</span> <span class="sy0">*</span> <span class="kw4">const</span> tier<span class="br0">[</span><span class="br0">]</span> PROGMEM <span class="sy0">=</span> 
<span class="br0">{</span>
   hund<span class="sy0">,</span> katze<span class="sy0">,</span> maus
<span class="br0">}</span><span class="sy0">;</span></pre></div></div>
</td></tr></tbody></table></dd></dl>
<p>Nachher:
</p>
<dl><dd><table>

<tbody><tr>
<td><div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">static</span> <span class="kw4">const</span> __flash <span class="kw4">char</span> hund<span class="br0">[</span><span class="br0">]</span>  <span class="sy0">=</span> <span class="st0">"Hund"</span><span class="sy0">;</span>
<span class="kw4">static</span> <span class="kw4">const</span> __flash <span class="kw4">char</span> katze<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"Katze"</span><span class="sy0">;</span>
<span class="kw4">static</span> <span class="kw4">const</span> __flash <span class="kw4">char</span> maus<span class="br0">[</span><span class="br0">]</span>  <span class="sy0">=</span> <span class="st0">"Maus"</span><span class="sy0">;</span>
&nbsp;
<span class="kw4">const</span> __flash <span class="kw4">char</span> <span class="sy0">*</span> <span class="kw4">const</span> __flash tier<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> 
<span class="br0">{</span>
   hund<span class="sy0">,</span> katze<span class="sy0">,</span> maus
<span class="br0">}</span><span class="sy0">;</span></pre></div></div>
</td></tr></tbody></table></dd></dl>
<p>Der Header <tt>avr/pgmspace.h</tt> wird nicht mehr benötigt.  Im Gegensatz zu <tt>progmem</tt> müssen Qualifier immer links von der definierten Variablen stehen; bei Attributen wie <tt>progmem</tt> ist das mehr oder weniger egal.
</p><p>Nachdem diese Anpassung erfolgreich abgeschlossen ist, folgt Schritt
</p>
<dl>
<dt> 2. Der Code wird von <tt>pgm_reg</tt>-Aufrufen bereinigt</dt>
<dd>
</dd>
</dl>
<p>Vorher:
</p>
<dl><dd><table>

<tbody><tr>
<td><div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/pgmspace.h&gt;</span>
&nbsp;
<span class="kw2">extern</span> <span class="kw4">const</span> <span class="kw4">char</span> <span class="sy0">*</span>tier<span class="br0">[</span><span class="br0">]</span><span class="sy0">;</span>
&nbsp;
<span class="kw4">char</span> first_letter <span class="br0">(</span><span class="kw4">uint8_t</span> i<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">const</span> <span class="kw4">char</span><span class="sy0">*</span> ptier <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">const</span> <span class="kw4">char</span><span class="sy0">*</span><span class="br0">)</span> pgm_read_word <span class="br0">(</span><span class="sy0">&amp;</span>tier<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">return</span> <span class="br0">(</span><span class="kw4">char</span><span class="br0">)</span> pgm_read_byte <span class="br0">(</span><span class="sy0">&amp;</span>ptier<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
</td></tr></tbody></table></dd></dl>
<p>Nachher:
</p>
<dl><dd><table>

<tbody><tr>
<td><div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;stdint.h&gt;</span>
&nbsp;
<span class="kw2">extern</span> <span class="kw4">const</span> __flash <span class="kw4">char</span> <span class="sy0">*</span> <span class="kw4">const</span> __flash tier<span class="br0">[</span><span class="br0">]</span><span class="sy0">;</span>
&nbsp;
<span class="kw4">char</span> first_letter <span class="br0">(</span><span class="kw4">uint8_t</span> i<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">return</span> tier<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
</td></tr></tbody></table></dd></dl>
<p><br>
</p>
<h2><span class="mw-headline" id="Flash_in_der_Anwendung_schreiben">Flash in der Anwendung schreiben</span></h2>
<p>Bei AVRs mit "self-programming"-Option – auch bekannt als <a href="http://www.mikrocontroller.net/articles/Bootloader" title="Bootloader">Bootloader</a>-Support – können Teile des Flash-Speichers vom Anwendungsprogramm beschrieben werden. Dies ist nur möglich, wenn die Schreibfunktion in einem besonderen Speicherbereich, der Boot-Section des Programmspeichers/Flash, abgelegt ist.
</p><p>Bei einigen kleinen AVRs gibt es keine gesonderte Boot-Section, bei diesen kann der Flashspeicher von jeder Stelle des Programms geschrieben werden. Für Details sei hier auf das jeweilige Controller-Datenblatt und die Erläuterungen zum Modul boot.h der avr-libc verwiesen. Es existieren auch Application-Notes dazu bei atmel.com, die auf avr-gcc-Code übertragbar sind.
</p><p>Siehe auch: 
</p>
<ul>
<li> Forumsbeitrag <a class="external text" href="http://www.mikrocontroller.net/topic/163632#1561622">Daten in Programmspeicher speichern</a>
</li>
</ul>
<h2><span class="mw-headline" id="EEPROM">EEPROM</span></h2>
<p>Möchte man Werte aus einem Programm heraus so speichern, dass sie auch nach dem Abschalten der Versorgungsspannung noch vorhanden sind und nach dem Wiederherstellen der Versorgungsspannung bei erneutem Programmstart wieder zur Verfügung stehen, dann benutzt man das EEPROM.
</p><p>Schreib- und Lesezugriffe auf den EEPROM-Speicher erfolgen über die im Modul eeprom.h der avr-libc definierten Funktionen. Mit diesen Funktionen können einzelne Bytes, Datenworte (16bit), Fließkommawerte (32-Bit, single-precision, float) und Datenblöcke geschrieben und gelesen werden. 
</p><p>Diese Funktionen kümmern sich auch um diverse Details, die bei der Benutzung des EEPROMS normalerweise notwendig sind:
</p>
<ul>
<li> EEPROM Operationen sind im Vergleich relativ langsam. Man muss daher darauf achten, dass eine vorhergehende Operation abgeschlossen ist, ehe die nächste Operation mit dem EEPROM gestartet wird. Die in der avr-libc implementierten Funktionen aus eeprom.h berücksichtigten dies. Soll beim Aufruf einer EEPROM-Funktion sicher gestellt werden, dass diese nicht intern in einer Warteschleife auf den Abschluss der vorherigen Operation wartet, kann vorher per eeprom_is_ready testen, ob der Zugriff auf den EEPROM-Speicher sofort möglich ist.
</li>
<li> Es ist darauf zu achten, dass die EEPROM Funktionen nicht durch einen Interrupt unterbrochen werden können. Einige Phasen des Zugriffs sind zeitkritisch und müssen in einer definierten Anzahl Takte durchgeführt werden. Durch einen unterbrechenden Interrupt würde diese Restriktion nicht mehr eingehalten. Auch dieses Detail wird von den avr-libc Funktionen berücksichtigt, so dass man sich als C Programmierer nicht darum kümmern muss. Innerhalb der Funktionen werden Interrupts vor der "EEPROM-Sequenz" global deaktiviert und im Anschluss, falls vorher auch schon eingeschaltet, wieder aktiviert.
</li>
</ul>
<p>Man beachte, dass der EEPROM-Speicher nur eine begrenzte Anzahl von Schreibzugriffen zulässt. Beschreibt man eine EEPROM-Zelle öfter als die im Datenblatt zugesicherte Anzahl (typisch 100.000), wird die Funktion der Zelle nicht mehr garantiert. Dies gilt für jede einzelne Zelle. 
</p><p>Bei geschickter Programmierung (z.&nbsp;B. Ring-Puffer), bei der die zu beschreibenden Zellen regelmäßig gewechselt werden, kann man eine deutlich höhere Anzahl an Schreibzugriffen, bezogen auf den gesamten EEPROM-Speicher, erreichen. Auf jeden Fall sollte man aber eine Abschätzung über die zu erwartende Lebensdauer des EEPROM durchführen. Wird ein Wert im EEPROM im Durchschnitt nur einmal pro Woche verändert, wird die garantierte Anzahl der Schreibzyklen innerhalb der voraussichtlichen Verwendungszeit des Controllers wahrscheinlich nicht erreicht. In diesem Fall lohnt es sich daher nicht, erweiterte Programmfunktionen zu implementieren, mit denen die Anzahl der Schreibzugriffe minimiert wird. 
</p><p>Eine weitere Möglichkeit Schreibzyklen einzusparen besteht darin, dass geprüft wird, ob im EEPROM bereits der zu speichernde Wert enthalten ist und nur veränderte Werte zu schreiben. In aktuelleren Versionen der avr-libc sind bereits Funktionen enthalten, die solche Prüfungen enthalten (eeprom_update_*).
</p><p>Lesezugriffe können beliebig oft durchgeführt werden. Sie unterliegen keinen Einschränkungen in Bezug auf deren Anzahl. 
</p>
<h3><span class="mw-headline" id="EEMEM">EEMEM</span></h3>
<p>Um eine Variable im EEPROM anzulegen, stellt die avr-libc das Makro EEMEM zur Verfügung:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;stdint.h&gt;</span>
<span class="co2">#include &lt;avr/eeprom.h&gt;</span>
&nbsp;
<span class="coMULTI">/* Byte */</span>
<span class="kw4">uint8_t</span> eeFooByte EEMEM <span class="sy0">=</span> <span class="nu0">123</span><span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* Wort */</span>
<span class="kw4">uint16_t</span> eeFooWord EEMEM <span class="sy0">=</span> <span class="nu0">12345</span><span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* float */</span>
<span class="kw4">float</span> eeFooFloat EEMEM<span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* Byte-Array */</span>
<span class="kw4">uint8_t</span> eeFooByteArray1<span class="br0">[</span><span class="br0">]</span> EEMEM <span class="sy0">=</span> <span class="br0">{</span> <span class="nu0">18</span><span class="sy0">,</span> <span class="nu0">3</span><span class="sy0">,</span> <span class="nu0">70</span> <span class="br0">}</span><span class="sy0">;</span>
<span class="kw4">uint8_t</span> eeFooByteArray2<span class="br0">[</span><span class="br0">]</span> EEMEM <span class="sy0">=</span> <span class="br0">{</span> <span class="nu0">30</span><span class="sy0">,</span> <span class="nu0">7</span><span class="sy0">,</span> <span class="nu0">79</span> <span class="br0">}</span><span class="sy0">;</span>
&nbsp;
<span class="coMULTI">/* 16-bit unsigned short feld */</span>
<span class="kw4">uint16_t</span> eeFooWordArray1<span class="br0">[</span><span class="nu0">4</span><span class="br0">]</span> EEMEM<span class="sy0">;</span></pre></div></div>
<p>Die grundsätzliche Vorgehensweise ist identisch zur Verwendung von PROGMEM. Auch hier erzeugt man sich spezielle attributierte Variablen (EEMEM erledigt das), die vom Compiler/Linker nicht wie normale Variablen behandelt werden. Compiler/Linker kümmern sich zwar darum, dass diesen Variablen eine Adresse zugewiesen wird, diese Adresse ist dann aber die Adresse der 'Variablen' im EEPROM. Um die dort gespeicherten Werte zu lesen bzw. zu schreiben, übergibt man diese Adresse an spezielle Funktionen, die die entsprechenden Werte aus dem EEPROM holen bzw. das EEPROM neu beschreiben.
</p><p>Die mittels EEMEM erzeugten 'Variablen' sind also mehr als Platzhalter zu verstehen, denn als echte Variablen. Es geht nur darum, im C Programm symbolische Namen zur Verfügung zu haben, anstatt mit echten EEPROM Adressen hantieren zu müssen - etwas das grundsätzlich aber auch genauso gut möglich ist. Nur muss man sich in diesem Fall dann selbst darum kümmern, dass mehrere 'Variablen' ohne Überschneidung im EEPROM angeordnet werden.
</p>
<h3><span class="mw-headline" id="Bytes_lesen.2Fschreiben">Bytes lesen/schreiben</span></h3>
<p>Die avr-libc Funktion zum Lesen eines Bytes heißt eeprom_read_byte. Parameter ist die Adresse des Bytes im EEPROM. Geschrieben wird über die Funktion eeprom_write_byte mit den Parametern Adresse und Inhalt. Anwendungsbeispiel:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#define EEPROM_DEF 0xFF</span>
&nbsp;
<span class="kw4">void</span> eeprom_example <span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">uint8_t</span> myByte<span class="sy0">;</span>
&nbsp;
    <span class="co1">// myByte lesen (Wert = 123)</span>
    myByte <span class="sy0">=</span> eeprom_read_byte <span class="br0">(</span><span class="sy0">&amp;</span>eeFooByte<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// der Wert 99 wird im EEPROM an die Adresse der</span>
    <span class="co1">// Variablen eeFooByte geschrieben</span>
    myByte <span class="sy0">=</span> <span class="nu0">99</span><span class="sy0">;</span>
    eeprom_write_byte<span class="br0">(</span><span class="sy0">&amp;</span>eeFooByte<span class="sy0">,</span> myByte<span class="br0">)</span><span class="sy0">;</span> <span class="co1">// schreiben</span>
&nbsp;
    myByte <span class="sy0">=</span> eeprom_read_byte <span class="br0">(</span><span class="sy0">&amp;</span>eeFooByteArray1<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
    <span class="co1">// myByte hat nun den Wert 3</span>
&nbsp;
    <span class="co1">// Beispiel fuer eeprom_update_byte: die EEPROM-Zelle wird nur</span>
    <span class="co1">// dann beschrieben, wenn deren Inhalt sich vom Parameterwert</span>
    <span class="co1">// unterscheidet. In diesem Beispiel erfolgt also kein Schreib-</span>
    <span class="co1">// zugriff, da die Werte gleich sind.</span>
    eeprom_update_byte<span class="br0">(</span><span class="sy0">&amp;</span>eeFooByte<span class="sy0">,</span> myByte<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
&nbsp;
    <span class="co1">// Beispiel zur "Sicherung" gegen leeres EEPROM nach "Chip Erase"</span>
    <span class="co1">// (z. B. wenn die .eep-Datei nach Programmierung einer neuen Version</span>
    <span class="co1">// des Programms nicht in den EEPROM uebertragen wurde und EESAVE</span>
    <span class="co1">// deaktiviert ist (unprogrammed/1)</span>
    <span class="co1">// </span>
    <span class="co1">// Vorsicht: wenn EESAVE "programmed" ist, hilft diese Sicherung nicht</span>
    <span class="co1">// weiter, da die Speicheraddressen in einem neuen/erweiterten Programm</span>
    <span class="co1">// moeglicherweise verschoben wurden. An der Stelle &amp;eeFooByte steht</span>
    <span class="co1">// dann u.U. der Wert einer anderen Variable aus einer "alten" Version.</span>
&nbsp;
    <span class="kw4">uint8_t</span> fooByteDefault <span class="sy0">=</span> <span class="nu0">222</span><span class="sy0">;</span>
    <span class="kw1">if</span> <span class="br0">(</span><span class="br0">(</span>myByte <span class="sy0">=</span> eeprom_read_byte <span class="br0">(</span><span class="sy0">&amp;</span>eeFooByte<span class="br0">)</span><span class="br0">)</span> <span class="sy0">==</span> EEPROM_DEF<span class="br0">)</span>
    <span class="br0">{</span>
        myByte <span class="sy0">=</span> fooByteDefault<span class="sy0">;</span>
    <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<h3><span class="mw-headline" id="Wort_lesen.2Fschreiben">Wort lesen/schreiben</span></h3>
<p>Schreiben und Lesen von Datenworten erfolgt analog zur Vorgehensweise bei Bytes:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1">    <span class="co1">// lesen</span>
    <span class="kw4">uint16_t</span> myWord <span class="sy0">=</span> eeprom_read_word <span class="br0">(</span><span class="sy0">&amp;</span>eeFooWord<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// schreiben</span>
    eeprom_write_word <span class="br0">(</span><span class="sy0">&amp;</span>eeFooWord<span class="sy0">,</span> <span class="nu0">2222</span><span class="br0">)</span><span class="sy0">;</span></pre></div></div>
<h3><span class="mw-headline" id="Block_lesen.2Fschreiben">Block lesen/schreiben</span></h3>
<p>Lesen und Schreiben von Datenblöcken erfolgt über die Funktionen <code>eeprom_read_block()</code> bzw. <code>eeprom_write_block()</code>. Die Funktionen erwarten drei Parameter: die Adresse der Quell- bzw. Zieldaten im RAM, die EEPROM-Addresse und die Länge des Datenblocks in Bytes als <code>size_t</code>.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="kw4">uint8_t</span>  myByteBuffer<span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span><span class="sy0">;</span>
<span class="kw4">uint16_t</span> myWordBuffer<span class="br0">[</span><span class="nu0">4</span><span class="br0">]</span><span class="sy0">;</span>
&nbsp;
<span class="kw4">void</span> eeprom_block_example <span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="coMULTI">/* Datenblock aus EEPROM lesen  */</span>
&nbsp;
    <span class="coMULTI">/* liest 3 Bytes ab der von eeFooByteArray1 definierten EEPROM-Adresse
       in das RAM-Array myByteBuffer */</span>
    eeprom_read_block <span class="br0">(</span>myByteBuffer<span class="sy0">,</span> eeFooByteArray1<span class="sy0">,</span> <span class="nu0">3</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="coMULTI">/* dito mit etwas Absicherung betr. der Länge */</span>
    eeprom_read_block <span class="br0">(</span>myByteBuffer<span class="sy0">,</span> eeFooByteArray1<span class="sy0">,</span> <span class="kw4">sizeof</span><span class="br0">(</span>myByteBuffer<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="coMULTI">/* und nun mit 16-Bit Array */</span>
    eeprom_read_block <span class="br0">(</span>myWordBuffer<span class="sy0">,</span> eeFooWordArray1<span class="sy0">,</span> <span class="kw4">sizeof</span><span class="br0">(</span>myWordBuffer<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="coMULTI">/* Datenblock in EEPROM schreiben */</span>
    eeprom_write_block <span class="br0">(</span>myByteBuffer<span class="sy0">,</span> eeFooByteArray1<span class="sy0">,</span> <span class="kw4">sizeof</span><span class="br0">(</span>myByteBuffer<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    eeprom_write_block <span class="br0">(</span>myWordBuffer<span class="sy0">,</span> eeFooWordArray1<span class="sy0">,</span> <span class="kw4">sizeof</span><span class="br0">(</span>myWordBuffer<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<h3><span class="mw-headline" id="Flie.C3.9Fkommawerte_lesen.2Fschreiben">Fließkommawerte lesen/schreiben</span></h3>
<p>In der avr-libc stehen auch EEPROM-Funktionen für Variablen des Typs float (Fließkommazahlen mit "einfacher" Genauigkeit) zur Verfügung.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/eeprom.h&gt;</span>
&nbsp;
<span class="kw4">float</span> eeFloat EEMEM <span class="sy0">=</span> <span class="nu17">12.34f</span><span class="sy0">;</span>
&nbsp;
<span class="kw4">float</span> <span class="kw4">void</span> eeprom_float_example<span class="br0">(</span><span class="kw4">float</span> value<span class="br0">)</span>
<span class="br0">{</span>
   <span class="coMULTI">/* float in EEPROM schreiben */</span>
   eeprom_write_float<span class="br0">(</span><span class="sy0">&amp;</span>eeFloat<span class="sy0">,</span> value<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
   <span class="coMULTI">/* float aus EEPROM lesen */</span>
   <span class="kw1">return</span>  eeprom_read_float<span class="br0">(</span><span class="sy0">&amp;</span>eeFloat<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<h3><span class="mw-headline" id="EEPROM-Speicherabbild_in_.eep-Datei">EEPROM-Speicherabbild in .eep-Datei</span></h3>
<p>Mit den zum Compiler gehörenden Werkzeugen kann der aus den Variablendeklarationen abgeleitete EEPROM-Inhalt in eine Datei geschrieben werden. Die übliche Dateiendung ist .eep, Daten im Intel Hex-Format. Damit können Standardwerte für den EEPROM-Inhalt im Quellcode definiert werden. 
</p><p>Makefiles nach WinAVR/MFile-Vorlage enthalten bereits die notwendigen Einstellungen, siehe dazu die Erläuterungen im <a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial/Exkurs_Makefiles" title="AVR-GCC-Tutorial/Exkurs Makefiles">Exkurs Makefiles</a>.
</p><p>Der Inhalt der eep-Datei muss ebenfalls zum Mikrocontroller übertragen werden, wenn die Initialisierungswerte aus der Deklaration vom Programm erwartet werden. Ansonsten enthält der EEPROM-Speicher nach der Übertragung des Programmers mittels ISP abhängig von der Einstellung der EESAVE-Fuse<sup id="cite_ref-11" class="reference"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#cite_note-11">[11]</a></sup> nicht die korrekten Werte:
</p>
<dl>
<dt> EESAVE = 0 (programmed)</dt>
<dd> Die Daten im EEPROM bleiben erhalten. Werden sie nicht neu geschrieben, so enthält das EEPROM evtl. Daten, die nicht mehr zum Programm passen.
</dd>
<dt> EESAVE = 1 (unprogrammed)</dt>
<dd> Beim Programmieren werden die Daten im EEPROM gelöscht, also auf 0xff gesetzt.
</dd>
</dl>
<p>Als Sicherung kann man im Programm nochmals die Standardwerte vorhalten, beim Lesen auf 0xFF prüfen und gegebenenfalls einen Standardwert nutzen.
</p>
<h3><span class="mw-headline" id="Direkter_Zugriff_auf_EEPROM-Adressen">Direkter Zugriff auf EEPROM-Adressen</span></h3>
<p>Will man direkt auf bestimmte EEPROM Adressen zugreifen, dann sind folgende Funktionen hilfreich, um sich die Typecasts zu ersparen:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/eeprom.h&gt;</span>
&nbsp;
<span class="co1">// Byte aus dem EEPROM lesen</span>
<span class="kw4">uint8_t</span> EEPReadByte<span class="br0">(</span><span class="kw4">uint16_t</span> addr<span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw1">return</span> eeprom_read_byte<span class="br0">(</span><span class="br0">(</span><span class="kw4">uint8_t</span> <span class="sy0">*</span><span class="br0">)</span>addr<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
&nbsp;
<span class="co1">// Byte in das EEPROM schreiben</span>
<span class="kw4">void</span> EEPWriteByte<span class="br0">(</span><span class="kw4">uint16_t</span> addr<span class="sy0">,</span> <span class="kw4">uint8_t</span> val<span class="br0">)</span>
<span class="br0">{</span>
  eeprom_write_byte<span class="br0">(</span><span class="br0">(</span><span class="kw4">uint8_t</span> <span class="sy0">*</span><span class="br0">)</span>addr<span class="sy0">,</span> val<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<p>oder als Makro:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#define   EEPReadByte(addr)         eeprom_read_byte((uint8_t *)addr)     </span>
<span class="co2">#define   EEPWriteByte(addr, val)   eeprom_write_byte((uint8_t *)addr, val)</span></pre></div></div>
<p>Verwendung:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1">EEPWriteByte<span class="br0">(</span><span class="nu12">0x20</span><span class="sy0">,</span> <span class="nu0">128</span><span class="br0">)</span><span class="sy0">;</span>   <span class="co1">// Byte an die Adresse 0x20 schreiben</span>
...
<span class="me1">Val</span><span class="sy0">=</span>EEPReadByte<span class="br0">(</span><span class="nu12">0x20</span><span class="br0">)</span><span class="sy0">;</span>     <span class="co1">// EEPROM-Wert von Adresse 0x20 lesen</span></pre></div></div>
<h3><span class="mw-headline" id="EEPROM_Register">EEPROM Register</span></h3>
<p>Um das EEPROM anzusteuern, sind drei Register von Bedeutung:
</p>
<dl>
<dt>EEAR</dt>
<dd> Hier werden die Adressen eingetragen zum Schreiben oder Lesen. Dieses Register unterteilt sich nochmal in EEARH und EEARL, da in einem 8-Bit-Register keine 512 Adressen adressiert werden können.
</dd>
<dt>EEDR</dt>
<dd> Hier werden die Daten eingetragen, die geschrieben werden sollen, bzw. es enthält die gelesenen Daten.
</dd>
<dt>EECR</dt>
<dd> Ist das Kontrollregister für das EEPROM
</dd>
</dl>
<p>Das EECR steuert den Zugriff auf das EEPROM und ist wie folgt aufgebaut:
</p>
<dl><dd><table class="wikitable" style="text-align:center">
<caption> <b>Aufbau des EECR-Registers</b>
</caption>
<tbody><tr>
<th>Bit
</th>
<td> 7 </td>
<td> 6 </td>
<td> 5 </td>
<td> 4 </td>
<td> 3 </td>
<td> 2 </td>
<td> 1 </td>
<td> 0
</td></tr>
<tr>
<th> Name
</th>
<td> - </td>
<td> - </td>
<td> - </td>
<td>- </td>
<td> EERIE </td>
<td> EEMWE </td>
<td> EEWE </td>
<td> EERE
</td></tr>
<tr>
<th> Read/Write
</th>
<td> R </td>
<td> R </td>
<td> R </td>
<td> R </td>
<td> R/W </td>
<td> R/W </td>
<td> R/W </td>
<td> R/W
</td></tr>
<tr>
<th>Init Value
</th>
<td> 0 </td>
<td> 0 </td>
<td> 0 </td>
<td> 0 </td>
<td> 0 </td>
<td> 0 </td>
<td> 0 </td>
<td> 0
</td></tr></tbody></table></dd></dl>
<p><b>Bedeutung der Bits</b>
</p>
<dl>
<dt>Bit 4-7</dt>
<dd> nicht belegt
</dd>
</dl>
<dl>
<dt>Bit 3 (EERIE)</dt>
<dd> <i>EEPROM Ready Interrupt Enable</i>: Wenn das Bit gesetzt ist und globale Interrupts erlaubt sind in Register SREG (Bit 7), wird ein Interrupt ausgelöst nach Beendigung des Schreibzyklus (EEPROM Ready Interrupt). Ist einer der beiden Bits 0, wird kein Interrupt ausgelöst.
</dd>
</dl>
<dl>
<dt>Bit 2 EEMWE)</dt>
<dd> <i>EEPROM Master Write Enable</i>: Dieses Bit bestimmt, dass, wenn EEWE = 1 gesetzt wird (innerhalb von 4 Taktzyklen), das EEPROM beschrieben wird mit den Daten in EEDR bei Adresse EEAR. Wenn EEMWE = 0 ist und EEWE = 1 gesetzt wird, hat das keine Auswirkungen. Der Schreibvorgang wird dann nicht ausgelöst. Nach 4 Taktzyklen wird das Bit EEMWE automatisch wieder auf 0 gesetzt. Dieses Bit löst den Schreibvorgang nicht aus, es dient sozusagen als Sicherungsbit für EEWE.
</dd>
</dl>
<dl>
<dt>Bit 1 (EEWE)</dt>
<dd> <i>EEPROM Write Enable</i>: Dieses Bit löst den Schreibvorgang aus, wenn es auf 1 gesetzt wird, sofern vorher EEMWE gesetzt wurde und seitdem nicht mehr als 4 Taktzyklen vergangen sind. Wenn der Schreibvorgang abgeschlossen ist, wird dieses Bit automatisch wieder auf 0 gesetzt und, sofern EERIE gesetzt ist, ein Interrupt ausgelöst. Ein Schreibvorgang sieht typischerweise wie folgt aus:
<ol>
<li> EEPROM-Bereitschaft abwarten (EEWE=0) 
</li>
<li> Adresse übergeben an EEAR
</li>
<li> Daten übergeben an EEDR
</li>
<li> Schreibvorgang auslösen in EECR mit Bit EEMWE=1 und EEWE=1
</li>
<li> (Optional) Warten, bis Schreibvorgang abgeschlossen ist
</li>
</ol>
</dd>
</dl>
<dl>
<dt>Bit 0 EERE</dt>
<dd> <i>EEPROM Read Enable</i>: Wird dieses Bit auf 1 gesetzt wird das EEPROM an der Adresse in EEAR ausgelesen und die Daten in EEDR gespeichert. Das EEPROM kann nicht ausgelesen werden, wenn bereits eine Schreiboperation gestartet wurde. Es ist daher zu empfehlen, die Bereitschaft vorher zu prüfen. Das EEPROM ist lesebereit, wenn das Bit EEWE=0 ist. Ist der Lesevorgang abgeschlossen, wird das Bit wieder auf 0 gesetzt, und das EEPROM ist für neue Lese- und Schreibbefehle wieder bereit. Ein typischer Lesevorgang kann wie folgt aufgebaut sein:
<ol>
<li> Bereitschaft zum Lesen prüfen (EEWE=0)
</li>
<li> Adresse übergeben an EEAR
</li>
<li> Lesezyklus auslösen mit EERE = 1
</li>
<li> Warten, bis Lesevorgang abgeschlossen EERE = 0
</li>
<li> Daten abholen aus EEDR
</li>
</ol>
</dd>
</dl>
<h1><span class="mw-headline" id="Die_Nutzung_von_sprintf_und_printf">Die Nutzung von sprintf und printf</span></h1>
<p>Um komfortabel, d.h. formatiert, Ausgaben auf ein Display oder die serielle Schnittstelle zu tätigen, bieten sich <b>sprintf</b> oder <b>printf</b> an. Alle *printf-Varianten sind jedoch ziemlich speicherintensiv und der Einsatz in einem Mikrocontroller mit knappem Speicher muss sorgsam abgewogen werden.
</p><p>Bei <b>sprintf</b> wird die Ausgabe zunächst in einem Puffer vorbereitet und anschließend mit einfachen Funktionen zeichenweise ausgegeben. Es liegt in der Verantwortung des Programmierers, genügend Platz im Puffer für die erwarteten Zeichen bereitzuhalten.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt;</span>
<span class="co2">#include &lt;stdint.h&gt;</span>
&nbsp;
<span class="co1">// ...</span>
<span class="co1">// nicht dargestellt: Implementierung von uart_puts (vgl. Abschnitt UART)</span>
<span class="co1">// ...</span>
&nbsp;
<span class="kw4">uint16_t</span> counter<span class="sy0">;</span>
&nbsp;
<span class="co1">// Ausgabe eines unsigned Integerwertes</span>
<span class="kw4">void</span> uart_puti<span class="br0">(</span> <span class="kw4">uint16_t</span> value <span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">uint8_t</span> puffer<span class="br0">[</span><span class="nu0">20</span><span class="br0">]</span><span class="sy0">;</span>
&nbsp;
    <span class="kw3">sprintf</span><span class="br0">(</span> puffer<span class="sy0">,</span> <span class="st0">"Zählerstand:&nbsp;%u"</span><span class="sy0">,</span> value <span class="br0">)</span><span class="sy0">;</span>
    uart_puts<span class="br0">(</span> puffer <span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
  counter <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
&nbsp;
  uart_puti<span class="br0">(</span> counter <span class="br0">)</span><span class="sy0">;</span>
  uart_puti<span class="br0">(</span> <span class="nu0">42</span> <span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<p>Eine weitere elegante Möglichkeit besteht darin, den STREAM stdout (Standardausgabe) auf eine eigene Ausgabefunktion umzuleiten. Dazu wird dem Ausgabemechanismus der C-Bibliothek eine neue Ausgabefunktion bekannt gemacht, deren Aufgabe es ist, ein einzelnes Zeichen auszugeben. Wohin die Ausgabe dann tatsächlich stattfindet, ist Sache der Ausgabefunktion. Im Beispiel unten wird auf UART ausgegeben. Alle anderen, höheren Funktionen wie z.&nbsp;B. <b>printf</b>, greifen letztendlich auf diese primitive Ausgabefunktion zurück. 
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;avr/io.h&gt;</span>
<span class="co2">#include &lt;stdio.h&gt;</span>
&nbsp;
<span class="kw4">void</span> uart_init<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
<span class="co1">// a. Deklaration der primitiven Ausgabefunktion</span>
<span class="kw4">int</span> uart_putchar<span class="br0">(</span><span class="kw4">char</span> c<span class="sy0">,</span> FILE <span class="sy0">*</span>stream<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
<span class="co1">// b. Umleiten der Standardausgabe stdout (Teil 1)</span>
<span class="kw4">static</span> FILE mystdout <span class="sy0">=</span> FDEV_SETUP_STREAM<span class="br0">(</span> uart_putchar<span class="sy0">,</span> NULL<span class="sy0">,</span> _FDEV_SETUP_WRITE <span class="br0">)</span><span class="sy0">;</span>
&nbsp;
<span class="co1">// c. Definition der Ausgabefunktion</span>
<span class="kw4">int</span> uart_putchar<span class="br0">(</span> <span class="kw4">char</span> c<span class="sy0">,</span> FILE <span class="sy0">*</span>stream <span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">if</span><span class="br0">(</span> c <span class="sy0">==</span> <span class="st0">'<span class="es1">\n</span>'</span> <span class="br0">)</span>
        uart_putchar<span class="br0">(</span> <span class="st0">'<span class="es1">\r</span>'</span><span class="sy0">,</span> stream <span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    loop_until_bit_is_set<span class="br0">(</span> UCSRA<span class="sy0">,</span> UDRE <span class="br0">)</span><span class="sy0">;</span>
    UDR <span class="sy0">=</span> c<span class="sy0">;</span>
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">void</span> uart_init<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="coMULTI">/* hier µC spezifischen Code zur Initialisierung */</span>
    <span class="coMULTI">/* des UART einfügen... s.o. im AVR-GCC-Tutorial */</span>
&nbsp;
    <span class="co1">// Beispiel: </span>
    <span class="co1">//</span>
    <span class="co1">// myAVR Board 1.5 mit externem Quarz Q1 3,6864 MHz</span>
    <span class="co1">// 9600 Baud 8N1</span>
&nbsp;
<span class="co2">#ifndef F_CPU</span>
<span class="co2">#define F_CPU 3686400</span>
<span class="co2">#endif</span>
<span class="co2">#define UART_BAUD_RATE 9600</span>
&nbsp;
<span class="co1">// Hilfsmakro zur UBRR-Berechnung ("Formel" laut Datenblatt)</span>
<span class="co2">#define UART_UBRR_CALC(BAUD_,FREQ_) ((FREQ_)/((BAUD_)*16L)-1)</span>
&nbsp;
    UCSRB <span class="sy0">|=</span> <span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>TXEN<span class="br0">)</span> <span class="sy0">|</span> <span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>RXEN<span class="br0">)</span><span class="sy0">;</span>    <span class="co1">// UART TX und RX einschalten</span>
    UCSRC <span class="sy0">|=</span> <span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>URSEL<span class="br0">)</span><span class="sy0">|</span><span class="br0">(</span><span class="nu0">3</span><span class="sy0">&lt;&lt;</span>UCSZ0<span class="br0">)</span><span class="sy0">;</span>    <span class="co1">// Asynchron 8N1 </span>
&nbsp;
    UBRRH <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">uint8_t</span><span class="br0">)</span><span class="br0">(</span> UART_UBRR_CALC<span class="br0">(</span> UART_BAUD_RATE<span class="sy0">,</span> F_CPU <span class="br0">)</span> <span class="sy0">&gt;&gt;</span> <span class="nu0">8</span> <span class="br0">)</span><span class="sy0">;</span>
    UBRRL <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">uint8_t</span><span class="br0">)</span>UART_UBRR_CALC<span class="br0">(</span> UART_BAUD_RATE<span class="sy0">,</span> F_CPU <span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int16_t</span> antwort <span class="sy0">=</span> <span class="nu0">42</span><span class="sy0">;</span>
    uart_init<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// b. Umleiten der Standardausgabe stdout (Teil 2)</span>
    stdout <span class="sy0">=</span> <span class="sy0">&amp;</span>mystdout<span class="sy0">;</span>
&nbsp;
    <span class="co1">// Anwendung</span>
    <span class="kw3">printf</span><span class="br0">(</span> <span class="st0">"Die Antwort ist&nbsp;%d.<span class="es1">\n</span>"</span><span class="sy0">,</span> antwort <span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span>
&nbsp;
<span class="co1">// Quelle: avr-libc-user-manual-1.4.3.pdf, S.74</span>
<span class="co1">//         + Ergänzungen</span></pre></div></div>
<p><br>
Sollen Fließkommazahlen ausgegeben werden, muss im Makefile eine andere (größere) Version der <a href="http://www.mikrocontroller.net/articles/FAQ#Aktivieren_der_Floating_Point_Version_von_sprintf_beim_WinAVR_mit_AVR-Studio" title="FAQ">printflib</a> eingebunden werden.
</p>
<h1><span class="mw-headline" id="Anmerkungen">Anmerkungen</span></h1>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#cite_ref-1"><span class="cite-accessibility-label">Hochspringen </span>↑</a></span> <span class="reference-text">Für eine Liste der unterstützten COntroller siehe die Dokumentation des Compilers oder <a rel="nofollow" class="external text" href="http://www.nongnu.org/avr-libc/user-manual/index.html#supported_devices">AVR-Libc: Supported Devices</a>.</span>
</li>
<li id="cite_note-2"><span class="mw-cite-backlink"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#cite_ref-2"><span class="cite-accessibility-label">Hochspringen </span>↑</a></span> <span class="reference-text">Aktuelle, stabile Versionen sind als Nightly Builds regelmäßig im <a rel="nofollow" class="external text" href="http://forums.codeblocks.org/">Forum</a> verfügbar.</span>
</li>
<li id="cite_note-3"><span class="mw-cite-backlink"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#cite_ref-3"><span class="cite-accessibility-label">Hochspringen </span>↑</a></span> <span class="reference-text">z.&nbsp;B. <a href="http://www.mikrocontroller.net/articles/Pony-Prog_Tutorial" title="Pony-Prog Tutorial">Ponyprog</a>, yapp, AVRStudio</span>
</li>
<li id="cite_note-4"><span class="mw-cite-backlink"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#cite_ref-4"><span class="cite-accessibility-label">Hochspringen </span>↑</a></span> <span class="reference-text">In Quellcodes, die für ältere Versionen des avr-gcc/der avr-libc entwickelt wurden, erfolgt der Schreibzugriff über die Funktion outp(). Aktuelle Versionen des Compilers unterstützen den Zugriff nun direkt, outp() ist nicht mehr erforderlich.</span>
</li>
<li id="cite_note-5"><span class="mw-cite-backlink"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#cite_ref-5"><span class="cite-accessibility-label">Hochspringen </span>↑</a></span> <span class="reference-text">Variablen der Speicherklasse <i>static storage</i> haben eine unbegrenzte Lebensdauer.  Beispiel für solche Variablen sind globale Variablen, aber auch static-Variablen innerhalb einer Funktion gehören dazu.  Beispiele für Variablen, die nicht <i>static storage</i> sind: auto-Variablen ("normale" lokale Variablen), register-Variablen, durch malloc geschaffene Objekte, etc.</span>
</li>
<li id="cite_note-6"><span class="mw-cite-backlink"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#cite_ref-6"><span class="cite-accessibility-label">Hochspringen </span>↑</a></span> <span class="reference-text">Damit ist der mögliche Speicherbereich für Flash-Konstanten auf 64kiB begrenzt. Einige pgmspace-Funktionen ermöglichen den Lesezugriff auf den gesamten Flash-Speicher, intern via Assembler-Anweisung ELPM. Die Initialisierungswerte des Speicherinhalts jenseits der 64kiB-Marke müssen dann jedoch auf anderem Weg angelegt werden, d.h. nicht per PROGMEM. Evtl. eigene Section und Linker-Optionen. Alt und nicht ganz korrekt: Die avr-libc pgmspace-Funktionen unterstützen nur die unteren 64kiB Flash bei Controllern mit mehr als 64kiB.</span>
</li>
<li id="cite_note-7"><span class="mw-cite-backlink"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#cite_ref-7"><span class="cite-accessibility-label">Hochspringen </span>↑</a></span> <span class="reference-text">ab avr-libc 1.7.0</span>
</li>
<li id="cite_note-8"><span class="mw-cite-backlink"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#cite_ref-8"><span class="cite-accessibility-label">Hochspringen </span>↑</a></span> <span class="reference-text">In unserem Hund-Katze-Maus Beispiel belegt die erste Variante 22 Bytes Daten und 18 Bytes Code, die zweite Variante mit 2-dimensionalem Array belegt 18 Bytes Daten und 20 Bytes Code. Gemessen wurde mit avr-gcc 4.8 -Os für ATmega8.</span>
</li>
<li id="cite_note-9"><span class="mw-cite-backlink"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#cite_ref-9"><span class="cite-accessibility-label">Hochspringen </span>↑</a></span> <span class="reference-text">Im Gegensatz zu einem Attribute wie <tt>progmem</tt> ist ein (Adress Space) Qualifier Teil des Zeiger-Typs.</span>
</li>
<li id="cite_note-10"><span class="mw-cite-backlink"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#cite_ref-10"><span class="cite-accessibility-label">Hochspringen </span>↑</a></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://sourceware.org/PR14406">Binutils PR14406</a>: Support .progmem&lt;N&gt;.data sections to work with GCC's <a rel="nofollow" class="external text" href="http://gcc.gnu.org/PR49868">PR49868</a>.</span>
</li>
<li id="cite_note-11"><span class="mw-cite-backlink"><a href="http://www.mikrocontroller.net/articles/AVR-GCC-Tutorial#cite_ref-11"><span class="cite-accessibility-label">Hochspringen </span>↑</a></span> <span class="reference-text">vgl. Datenblatt Abschnitt Fuse Bits</span>
</li>
</ol>
<h1><span class="mw-headline" id="TODO">TODO</span></h1>
<ul>
<li> Aktualisierung Register- und Bitbeschreibungen an aktuelle AVR
</li>
<li> "naked"-Funktionen
</li>
</ul>

<!-- 
NewPP limit report
CPU time usage: 1.032 seconds
Real time usage: 1.042 seconds
Preprocessor visited node count: 1369/1000000
Preprocessor generated node count: 3015/1000000
Post‐expand include size: 835/2097152 bytes
Template argument size: 343/2097152 bytes
Highest expansion depth: 3/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key uc_wiki:pcache:idhash:1309-0!*!0!!de!2!* and timestamp 20150317081915 and revision id 86634
 -->
</div>			<!-- /bodycontent -->
						<!-- printfooter -->
			<div class="printfooter">
			Von „<a href="http://www.mikrocontroller.net/wikisoftware/index.php?title=AVR-GCC-Tutorial&oldid=86634">http://www.mikrocontroller.net/wikisoftware/index.php?title=AVR-GCC-Tutorial&amp;oldid=86634</a>“			</div>
			<!-- /printfooter -->
									<!-- catlinks -->
			<div id="catlinks" class="catlinks"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="http://www.mikrocontroller.net/articles/Spezial:Kategorien" title="Spezial:Kategorien">Kategorie</a>: <ul><li><a href="http://www.mikrocontroller.net/articles/Kategorie:Avr-gcc_Tutorial" title="Kategorie:Avr-gcc Tutorial">Avr-gcc Tutorial</a></li></ul></div></div>			<!-- /catlinks -->
									<div class="visualClear"></div>
			<!-- debughtml -->
						<!-- /debughtml -->

      <!-- start adsense -->
            <!-- end adsense -->
      
      <div class="visualClear"></div>
    </div>
	</div>
  </td>
  <!-- google_ad_section_end -->
      </tr>
      </tbody></table>
      <!--
      <div class="visualClear"></div>
      <div id="footer" style="clear:both">
    <div id="f-poweredbyico"><a href="//www.mediawiki.org/"><img src="/wikisoftware/skins/common/images/poweredby_mediawiki_88x31.png" height="31" width="88" alt="Powered by MediaWiki" /></a></div>		<ul id="f-list">
	  <li id="f-lastmod"> Diese Seite wurde zuletzt am 12. Januar 2015 um 14:06 Uhr geändert.</li>	  <li id="f-viewcount">Diese Seite wurde bisher 3.819.409 mal abgerufen.</li>	  	  	  <li id="f-about"><a href="/articles/Uc-wiki:%C3%9Cber_Uc-wiki" title="Uc-wiki:Über Uc-wiki">Über Uc-wiki</a></li>	  <li id="f-disclaimer"><a href="/articles/Uc-wiki:Impressum" title="Uc-wiki:Impressum">Impressum</a></li>	</ul>
      </div>-->
    </div>
<div id="bottom">
  <div id="impress">
    <a href="mailto:webmaster@mikrocontroller.net?subject=Mikrocontroller.net">webmaster@mikrocontroller.net</a> – <a href="http://www.mikrocontroller.net/contact">Impressum</a> – <a href="http://www.mikrocontroller.net/user/conditions">Nutzungsbedingungen</a> – <a href="http://www.mikrocontroller.net/about/ads">Werbung auf Mikrocontroller.net</a>
  </div>
  <div id="powered">
<!--    powered by Ruby on Rails -->
  </div>
 <a href="http://www.mikrocontroller.net/util/rb"><!-- nothing --></a>
 <!-- <a href="http://www.mikrocontroller.net/hp/curlews.php">nothing to see here</a> -->
</div>

<script>/*<![CDATA[*/window.jQuery && jQuery.ready();/*]]>*/</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["ext.cite","mediawiki.action.view.postEdit","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest"],null,true);
}</script>
<script src="./AVR-GCC-Tutorial - Mikrocontroller.net_files/load(4).php"></script>
<script>if(window.mw){
mw.config.set({"wgBackendResponseTime":76});
}</script><iframe src="about:blank" width="0" height="0" style="visibility: hidden !important; display: none !important; opacity: 0 !important;"></iframe></div>
  

<div class="highslide-container" style="padding: 0px; border: none; margin: 0px; position: absolute; left: 0px; top: 0px; width: 100%; z-index: 1001; direction: ltr;"><a class="highslide-loading" title="Klick zum Abbrechen" href="javascript:;" style="position: absolute; top: -9999px; opacity: 0.75; z-index: 1;">Lade...</a><div style="display: none;"></div><table cellspacing="0" style="padding: 0px; border: none; margin: 0px; visibility: hidden; position: absolute; border-collapse: collapse; width: 0px;"><tbody style="padding: 0px; border: none; margin: 0px;"><tr style="padding: 0px; border: none; margin: 0px; height: auto;"><td style="padding: 0px; border: none; margin: 0px; line-height: 0; font-size: 0px; height: 20px; width: 20px; background: url(http://www.mikrocontroller.net/highslide/graphics/outlines/drop-shadow.png) 0px 0px;"></td><td style="padding: 0px; border: none; margin: 0px; line-height: 0; font-size: 0px; height: 20px; width: 20px; background: url(http://www.mikrocontroller.net/highslide/graphics/outlines/drop-shadow.png) 0px -40px;"></td><td style="padding: 0px; border: none; margin: 0px; line-height: 0; font-size: 0px; height: 20px; width: 20px; background: url(http://www.mikrocontroller.net/highslide/graphics/outlines/drop-shadow.png) -20px 0px;"></td></tr><tr style="padding: 0px; border: none; margin: 0px; height: auto;"><td style="padding: 0px; border: none; margin: 0px; line-height: 0; font-size: 0px; height: 20px; width: 20px; background: url(http://www.mikrocontroller.net/highslide/graphics/outlines/drop-shadow.png) 0px -80px;"></td><td class="drop-shadow highslide-outline" style="padding: 0px; border: none; margin: 0px; position: relative;"></td><td style="padding: 0px; border: none; margin: 0px; line-height: 0; font-size: 0px; height: 20px; width: 20px; background: url(http://www.mikrocontroller.net/highslide/graphics/outlines/drop-shadow.png) -20px -80px;"></td></tr><tr style="padding: 0px; border: none; margin: 0px; height: auto;"><td style="padding: 0px; border: none; margin: 0px; line-height: 0; font-size: 0px; height: 20px; width: 20px; background: url(http://www.mikrocontroller.net/highslide/graphics/outlines/drop-shadow.png) 0px -20px;"></td><td style="padding: 0px; border: none; margin: 0px; line-height: 0; font-size: 0px; height: 20px; width: 20px; background: url(http://www.mikrocontroller.net/highslide/graphics/outlines/drop-shadow.png) 0px -60px;"></td><td style="padding: 0px; border: none; margin: 0px; line-height: 0; font-size: 0px; height: 20px; width: 20px; background: url(http://www.mikrocontroller.net/highslide/graphics/outlines/drop-shadow.png) -20px -20px;"></td></tr></tbody></table></div></body></html>